{% extends "base.html" %}

{% block title %}Attack Surface - PenTest Notes{% endblock %}

{% block head %}
<style>
    /* Улучшение читаемости подсвеченных строк таблицы */
    .table-success {
        background-color: #198754 !important;
        color: #000000 !important;
    }
    
    .table-success strong {
        color: #000000 !important;
    }
    
    .table-success code {
        background-color: rgba(0, 0, 0, 0.2) !important;
        color: #000000 !important;
    }
    .table-success td small, .table-success td { color: #000000 !important; }
    
    /* Исправление белых полей ввода */
    #domainsPreview {
        background-color: #3d3d3d !important;
        border: 1px solid #555 !important;
        color: #e0e0e0 !important;
    }
    
    #siteUrl {
        background-color: #3d3d3d !important;
        border: 1px solid #555 !important;
        color: #e0e0e0 !important;
    }
    
    #siteUrl:focus {
        background-color: #3d3d3d !important;
        border-color: #0d6efd !important;
        color: #e0e0e0 !important;
        box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25) !important;
    }
    
    /* Исправление белого фона для предварительного просмотра портов */
    #portsPreview .border {
        background-color: #3d3d3d !important;
        border-color: #555 !important;
        color: #e0e0e0 !important;
    }
    
    #portsPreviewContent {
        background-color: #3d3d3d !important;
        color: #e0e0e0 !important;
    }
    
    /* Поле текстового вывода для CIDR результатов */
    #cidrResultsText {
        background-color: #3d3d3d !important;
        border: 1px solid #555 !important;
        color: #e0e0e0 !important;
    }
    #cidrResultsText:focus {
        background-color: #3d3d3d !important;
        border-color: #0d6efd !important;
        color: #e0e0e0 !important;
        box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25) !important;
    }

    /* Легенда портов */
    #portsLegendList {
        background-color: #2f2f2f;
        border: 1px solid #555;
        color: #e0e0e0;
        padding: 8px;
        border-radius: 6px;
    }
    #portsLegendCidrSelect {
        background-color: #3d3d3d !important;
        border: 1px solid #555 !important;
        color: #e0e0e0 !important;
    }
    #portsLegendCidrSelect option {
        background-color: #3d3d3d;
        color: #e0e0e0;
    }

    /* Контекстное меню для узлов CIDR */
.cidr-context-menu {
        position: absolute;
        background-color: #2f2f2f;
        border: 1px solid #555;
        border-radius: 6px;
        box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        min-width: 180px;
        display: none;
        overflow: hidden;
}
.cidr-context-menu .menu-item {
        padding: 8px 12px;
        cursor: pointer;
        color: #e0e0e0;
        font-size: 14px;
        white-space: nowrap;
}
.cidr-context-menu .menu-item:hover {
    background-color: #3d3d3d;
}
.cidr-context-menu .menu-item + .menu-item { border-top: 1px solid #444; }
#cidrFilterPanel { position: relative; z-index: 2001; pointer-events: auto; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h1><i class="fas fa-network-wired text-danger"></i> Attack Surface</h1>
                <div>
                    <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#createAttackSurfaceModal">
                        <i class="fas fa-plus"></i> Создать Attack Surface
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Список проектов и их Attack Surface -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0"><i class="fas fa-folder-open"></i> Проекты и Attack Surface</h5>
                </div>
                <div class="card-body">
                    <div id="projectsList">
                        <div class="d-flex align-items-center justify-content-center" style="min-height: 200px;">
                            <div class="text-center text-muted">
                                <div class="spinner-border" role="status">
                                    <span class="visually-hidden">Загрузка...</span>
                                </div>
                                <p class="mt-2">Загрузка проектов...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Граф Attack Surface -->
    <div class="row mb-4" id="graphSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-project-diagram"></i> Граф Attack Surface: <span id="currentAttackSurfaceName"></span></h5>
                    <div>
                        <button class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#addDomainsModal">
                            <i class="fas fa-plus"></i> Добавить домены
                        </button>
                        <button class="btn btn-warning btn-sm ms-2" onclick="showProjectNmapUploadModal()">
                            <i class="fas fa-upload"></i> Загрузить порты для проекта (XML)
                        </button>
                        <button class="btn btn-warning btn-sm ms-2" onclick="showProjectUdpUploadModal()">
                            <i class="fas fa-upload"></i> UDP для проекта (udpx.txt)
                        </button>
                        <button class="btn btn-dark btn-sm ms-2" onclick="showScopeModal()">
                            <i class="fas fa-bullseye"></i> InScope
                        </button>
                        <button class="btn btn-info btn-sm ms-2" onclick="showVhostModal()">
                            <i class="fas fa-server"></i> VHost CSV <span id="vhostCountBadge" class="badge bg-light text-dark" style="margin-left:6px">0</span>
                        </button>
                        <div class="btn-group ms-2" role="group" id="graphControls">
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="resetGraphZoom()" title="Сбросить масштаб">
                                <i class="fas fa-search-minus"></i>
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="centerGraph()" title="Центрировать граф">
                                <i class="fas fa-crosshairs"></i>
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-info" onclick="showGraphHelp()" title="Справка">
                                <i class="fas fa-question"></i>
                            </button>
                        </div>
                        <div class="form-check form-check-inline ms-2 align-middle">
                            <input class="form-check-input" type="checkbox" id="scopeOnlyCheckbox" onchange="toggleScopeOnly(this.checked)">
                            <label class="form-check-label" for="scopeOnlyCheckbox">Только scope</label>
                        </div>
                        <div class="ms-3" id="portsLegendContainer" style="display: none;"></div>
                    </div>
                </div>
                <div class="card-body">
    <div id="attackSurfaceGraph" style="height: 600px; border: 1px solid #404040; border-radius: 5px; position: relative; z-index: 1000;">
                        <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                            <div class="text-center">
                                <i class="fas fa-network-wired fa-3x mb-3"></i>
                                <p>Добавьте домены или IP адреса для построения графа attack surface</p>
                            </div>
                        </div>
                    </div>
                    <!-- Карточка результатов для выбранного CIDR -->
                    <div id="cidrResultsCard" class="card mt-3" style="display: none;">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h6 class="mb-0"><i class="fas fa-list"></i> Результаты: <span id="cidrResultsTitle"></span></h6>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearCidrResults()">
                                Очистить
                            </button>
                        </div>
                        <div class="card-body">
                            <textarea id="cidrResultsText" class="form-control" rows="8" readonly wrap="off"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Единая таблица CIDR, IP и доменов -->
    <div class="row" id="dataSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <input type="text" id="attackSurfaceSearch" class="form-control form-control-sm" placeholder="Поиск по таблице..." style="max-width:360px" oninput="applyAttackSurfaceSearch()">
                        <div class="d-flex flex-column align-items-start">
                            <div class="d-flex flex-wrap align-items-center gap-2">
                                <button class="btn btn-sm btn-outline-primary" onclick="showVisibleIps()"><i class="fas fa-list"></i> Получить IP</button>
                                <button class="btn btn-sm btn-outline-primary" onclick="showVisiblePorts()"><i class="fas fa-list"></i> Получить Порты</button>
                                <button class="btn btn-sm btn-outline-primary" onclick="showVisibleDomains()"><i class="fas fa-list"></i> Получить домены</button>
                                <button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureAll()"><i class="fas fa-camera"></i> Скриншоты для всей таблицы</button>
                                <button class="btn btn-sm btn-outline-danger" onclick="deleteAllScreenshotsForAttackSurface()"><i class="fas fa-trash"></i> Удалить все скриншоты</button>
                                
                            </div>
                        </div>
                    </div>
                <div class="card-body">
                    <div id="tableScreenshotsProgressPanel" class="alert alert-dark py-1 px-2 mb-2" style="display:none;background-color:#2d2d2d;border-color:#444;color:#cfe9dc">
                        <span class="text-success small">Прогресс:</span>
                        <span id="tableScreenshotsProgressBar" style="display:inline-block;width:180px;height:8px;background:#343a40;border-radius:8px;vertical-align:middle;overflow:hidden">
                            <span id="tableScreenshotsProgressFill" style="display:block;height:100%;width:0;background:#20c997;transition:width .2s ease"></span>
                        </span>
                        <span id="tableScreenshotsProgressText" class="text-success small ms-1">0%</span>
                        <span class="text-muted small ms-3">Текущий: <span id="tableScreenshotsCurrent"></span></span>
                    </div>
    <div class="table-responsive">
        <table class="table table-striped table-hover">
                            <thead class="table-dark">
                                <tr>
                                    <th style="cursor:pointer" onclick="setAttackSurfaceSort('cidr')">CIDR <i id="sortIndicatorCidr" class="fas fa-sort ms-1"></i></th>
                                    <th style="cursor:pointer" onclick="setAttackSurfaceSort('ip')">IP адрес <i id="sortIndicatorIp" class="fas fa-sort ms-1"></i></th>
                                    <th>Порты</th>
                                    <th style="cursor:pointer" onclick="setAttackSurfaceSort('domain')">Домен <i id="sortIndicatorDomain" class="fas fa-sort ms-1"></i></th>
                                    <th>Скриншот</th>
                                    <th style="cursor:pointer" onclick="setAttackSurfaceSort('status')">Статус <i id="sortIndicatorStatus" class="fas fa-sort ms-1"></i></th>
                                    <th>Действия</th>
                                </tr>
                            </thead>
                            <tbody id="attackSurfaceTableBody">
                                <tr>
                                    <td colspan="7" class="text-muted text-center">Данные появятся здесь после анализа</td>
                                </tr>
                            </tbody>
        </table>
    </div>
    
                    
                </div>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="vhostModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить VHost CSV</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Файлы CSV</label>
                    <input type="file" id="vhostFiles" class="form-control" accept=".csv" multiple>
                    <div class="form-text">Можно выбрать несколько файлов сразу</div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Суфикс домена</label>
                    <input type="text" id="vhostSuffix" class="form-control" placeholder="example.com">
                    <div class="form-text">Добавится как suffix к записям словаря (dev → dev.example.com)</div>
                </div>
                <div class="d-flex mb-2 gap-2">
                    <button class="btn btn-outline-info btn-sm" onclick="loadSavedVhostFindings()">Показать сохранённые VHost находки</button>
                    <button class="btn btn-outline-warning btn-sm" id="vhostClearBtn" type="button" onclick="clearVhostUploads(event)">Очистить загруженные</button>
                    <div class="ms-auto d-flex align-items-center gap-2" id="vhostFilters" style="display:none">
                        <label class="form-label mb-0">Фильтр:</label>
                        <select id="vhostFilterSelect" class="form-select form-select-sm" onchange="applyVhostFilter()" style="width:auto">
                            <option value="all">Все</option>
                            <option value="new">Новые домены</option>
                            <option value="resolved">Резолвятся</option>
                            <option value="code2xx">HTTP 2xx</option>
                            <option value="code3xx">HTTP 3xx</option>
                            <option value="code4xx">HTTP 4xx</option>
                            <option value="code5xx">HTTP 5xx</option>
                        </select>
                        <button class="btn btn-outline-success btn-sm" onclick="addSelectedVhostToAttackSurface()">Добавить выбранные в Attack Surface</button>
                    </div>
                </div>
                <div class="mb-3" id="vhostPreviewWrap" style="display:none">
                    <label class="form-label">Предпросмотр</label>
                    <div class="table-responsive" style="max-height:300px;overflow:auto">
                        <table class="table table-sm table-striped" id="vhostPreviewTable">
                            <thead>
                                <tr>
                                    <th style="width:28px"><input type="checkbox" id="vhostSelectAll" onclick="toggleVhostSelectAll(this)"></th>
                                    <th>Цель</th>
                                    <th>Запись</th>
                                    <th>Полный домен</th>
                                    <th>Статус</th>
                                    <th>В Attack Surface</th>
                                    <th>DNS</th>
                                </tr>
                            </thead>
                            <tbody id="vhostPreviewBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button class="btn btn-primary" onclick="importVhostFindings()">Импортировать</button>
            </div>
        </div>
    </div>
 </div>
<div class="modal fade" id="visibleIpsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">IP из таблицы</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2 d-flex gap-2">
                    <button class="btn btn-sm btn-outline-secondary" onclick="copyVisibleIps()"><i class="fas fa-copy"></i> Скопировать</button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="downloadVisibleIps()"><i class="fas fa-download"></i> Скачать</button>
                </div>
                <textarea id="visibleIpsContainer" class="form-control" rows="10" readonly style="background-color: #3d3d3d; color: #e0e0e0;"></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
            </div>
        </div>
    </div>
 </div>

<div class="modal fade" id="scopeModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить Scope</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="scopeFile" class="form-label">Файл со списком IP и доменов (по строкам)</label>
                    <input type="file" class="form-control" id="scopeFile" accept=".txt,.csv">
                    <div class="form-text">Поддерживаются IPv4 и домены 2-го уровня (root домены)</div>
                </div>
                <div class="mb-3">
                    <label for="scopePreview" class="form-label">Предварительный просмотр</label>
                    <textarea id="scopePreview" class="form-control" rows="8" readonly style="background-color:#3d3d3d;color:#e0e0e0"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button class="btn btn-primary" onclick="uploadScope()">Загрузить</button>
            </div>
        </div>
    </div>
 </div>

<div class="modal fade" id="visibleDomainsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Домены из таблицы</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2 d-flex gap-2">
                    <button class="btn btn-sm btn-outline-secondary" onclick="copyVisibleDomains()"><i class="fas fa-copy"></i> Скопировать</button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="downloadVisibleDomains()"><i class="fas fa-download"></i> Скачать</button>
                </div>
                <textarea id="visibleDomainsContainer" class="form-control" rows="10" readonly style="background-color: #3d3d3d; color: #e0e0e0;"></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
            </div>
        </div>
    </div>
 </div>

<!-- Контекстное меню для узлов CIDR -->
<div id="cidrContextMenu" class="cidr-context-menu">
    <div class="menu-item" data-action="get_ips">Получить IP</div>
    <div class="menu-item" data-action="get_domains">Получить домены</div>
    <div class="menu-item" data-action="get_asn">ASN/Организация</div>
    <div class="menu-item" data-action="upload_udp">Загрузить UDP порты</div>
    <div class="menu-item" data-action="upload_tcp">Загрузить TCP порты</div>
</div>

<div class="modal fade" id="screenshotModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Скриншот</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body text-center" style="background-color:#222">
                <img id="screenshotModalImage" src="" alt="Скриншот" class="img-fluid" style="max-height:70vh;object-fit:contain">
            </div>
            <div class="modal-footer d-flex justify-content-between">
                <div id="screenshotModalCaption" class="text-muted small"></div>
                <div>
                    <button type="button" class="btn btn-sm btn-outline-primary me-2" onclick="openScreenshotTarget()"><i class="fas fa-external-link-alt"></i></button>
                    <button type="button" class="btn btn-sm btn-outline-success me-2" onclick="createCardFromScreenshot()"><i class="fas fa-plus"></i></button>
                    <button type="button" class="btn btn-sm btn-outline-secondary me-2" onclick="prevScreenshot()"><i class="fas fa-chevron-left"></i></button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="nextScreenshot()"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
        </div>
    </div>
 </div>

<div class="modal fade" id="headersModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Заголовки для браузера</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <textarea id="headersText" class="form-control" rows="8" placeholder="JSON или строки вида\nHeader-Name: value"></textarea>
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="onlyWebCheckbox">
                    <label class="form-check-label" for="onlyWebCheckbox">Только веб (по портам)</label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="submitHeadersModal()"><i class="fas fa-camera"></i> Старт</button>
            </div>
        </div>
    </div>
 </div>
<div class="modal fade" id="visiblePortsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Порты из таблицы</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-2 d-flex gap-2">
                    <button class="btn btn-sm btn-outline-secondary" onclick="copyVisiblePorts()"><i class="fas fa-copy"></i> Скопировать</button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="downloadVisiblePorts()"><i class="fas fa-download"></i> Скачать</button>
                </div>
                <textarea id="visiblePortsContainer" class="form-control" rows="6" readonly style="background-color: #3d3d3d; color: #e0e0e0;"></textarea>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
            </div>
        </div>
    </div>
 </div>

<!-- Модальное окно для создания Attack Surface -->
<div class="modal fade" id="createAttackSurfaceModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Создать новый Attack Surface</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="createAttackSurfaceForm">
                    <div class="mb-3">
                        <label for="attackSurfaceName" class="form-label">Название Attack Surface</label>
                        <input type="text" class="form-control" id="attackSurfaceName" required>
                    </div>
                    <div class="mb-3">
                        <label for="attackSurfaceDescription" class="form-label">Описание</label>
                        <textarea class="form-control" id="attackSurfaceDescription" rows="3"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="attackSurfaceProject" class="form-label">Проект</label>
                        <select class="form-select" id="attackSurfaceProject" required>
                            <option value="">Выберите проект</option>
                        </select>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-success" onclick="createAttackSurface()">Создать</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="headersModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Заголовки для браузера</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <textarea id="headersText" class="form-control" rows="8" placeholder="JSON или строки вида\nHeader-Name: value"></textarea>
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="onlyWebCheckbox">
                    <label class="form-check-label" for="onlyWebCheckbox">Только веб (по портам)</label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="submitHeadersModal()"><i class="fas fa-camera"></i> Старт</button>
            </div>
        </div>
    </div>
 </div>

<!-- Модальное окно для добавления доменов -->
<div class="modal fade" id="addDomainsModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Добавить домены/адреса для анализа</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="addDomainsForm">
                    <div class="mb-3">
                        <label for="domainsFile" class="form-label">Загрузить файл с доменами и IP адресами</label>
                        <input type="file" class="form-control" id="domainsFile" accept=".txt,.csv" required>
                        <div class="form-text">Поддерживаются файлы .txt и .csv с доменами, IP адресами и CIDR блоками (каждый с новой строки)</div>
                    </div>
                    <div class="mb-3">
                        <label for="domainsPreview" class="form-label">Предварительный просмотр</label>
                        <textarea class="form-control" id="domainsPreview" rows="8" readonly 
                                  placeholder="Содержимое загруженного файла появится здесь..."></textarea>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="resolveDomains" checked>
                            <label class="form-check-label" for="resolveDomains">
                                Автоматически разрешать домены в IP адреса
                            </label>
                        </div>
                    </div>
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="detectCIDR" checked>
                            <label class="form-check-label" for="detectCIDR">
                                Автоматически определять CIDR блоки
                            </label>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-primary" onclick="analyzeAttackSurface()">Анализировать</button>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для создания сайта из домена -->
<div class="modal fade" id="createSiteModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Создать карточку сайта</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="createSiteForm">
                    <div class="mb-3">
                        <label for="siteName" class="form-label">Название сайта</label>
                        <input type="text" class="form-control" id="siteName" required>
                    </div>
                    <div class="mb-3">
                        <label for="siteUrl" class="form-label">URL</label>
                        <input type="url" class="form-control" id="siteUrl" readonly>
                    </div>
                    <div class="mb-3">
                        <label for="siteProject" class="form-label">Проект</label>
                        <select class="form-select" id="siteProject">
                            <option value="">Без проекта</option>
                        </select>
                    </div>
                    <input type="hidden" id="selectedDomain">
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-primary" onclick="createSiteFromDomain()">Создать сайт</button>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для загрузки XML портов -->
<div class="modal fade" id="uploadNmapPortsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить порты из Nmap XML</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="uploadNmapPortsForm">
                    <div class="mb-3">
                        <label for="targetIpSelect" class="form-label">Выберите IP-адрес</label>
                        <select class="form-select" id="targetIpSelect" required>
                            <option value="">Выберите IP-адрес для загрузки портов</option>
                        </select>
                        <div class="form-text">Порты будут добавлены для всех доменов на выбранном IP-адресе</div>
                    </div>
                    <div class="mb-3">
                        <label for="nmapXmlFile" class="form-label">Файл Nmap XML</label>
                        <input type="file" class="form-control" id="nmapXmlFile" accept=".xml" required>
                        <div class="form-text">Загрузите XML файл результатов сканирования Nmap</div>
                    </div>
                    <div class="mb-3" id="portsPreview" style="display: none;">
                        <label class="form-label">Найденные порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                            <div id="portsPreviewContent"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadNmapPorts()" id="uploadPortsBtn" disabled>Загрузить порты</button>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для быстрой загрузки портов при клике на IP -->
<div class="modal fade" id="quickPortUploadModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить порты для <span id="selectedIpAddress"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="quickPortUploadForm">
                    <div class="mb-3">
                        <label for="quickNmapXmlFile" class="form-label">Файл Nmap XML</label>
                        <input type="file" class="form-control" id="quickNmapXmlFile" accept=".xml" required>
                        <div class="form-text">Загрузите XML файл результатов сканирования Nmap для этого IP-адреса</div>
                    </div>
                    <div class="mb-3" id="quickPortsPreview" style="display: none;">
                        <label class="form-label">Найденные порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto; background-color: #3d3d3d; border-color: #555; color: #e0e0e0;">
                            <div id="quickPortsPreviewContent"></div>
                        </div>
                    </div>
                    <input type="hidden" id="targetIpForPorts">
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadQuickPorts()" id="quickUploadPortsBtn" disabled>Загрузить порты</button>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для загрузки UDP портов -->
<div class="modal fade" id="uploadUdpPortsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить UDP порты (udpx.txt)</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="uploadUdpPortsForm">
                    <!-- Удалено: выбор IP. Файл udpx.txt может содержать несколько адресов; парсим и загружаем по каждому адресу, который есть в графе. -->
                    <div class="mb-3">
                        <label for="udpTxtFile" class="form-label">Файл udpx.txt</label>
                        <input type="file" class="form-control" id="udpTxtFile" accept=".txt,.log,.json" required>
                        <div class="form-text">Каждая строка — JSON с полями address, port, service</div>
                    </div>
                    <div class="mb-3" id="udpPortsPreview" style="display: none;">
                        <label class="form-label">Найденные UDP порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto; background-color: #3d3d3d; border-color: #555; color: #e0e0e0;">
                            <div id="udpPortsPreviewContent"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadUdpPorts()" id="uploadUdpPortsBtn" disabled>Загрузить UDP порты</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="uploadTcpPortsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить TCP порты (Nmap XML)</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="uploadTcpPortsForm">
                    <div class="mb-3">
                        <label for="tcpXmlFile" class="form-label">Файл Nmap XML</label>
                        <input type="file" class="form-control" id="tcpXmlFile" accept=".xml" required>
                        <div class="form-text">Загрузка для IP из выбранного CIDR</div>
                    </div>
                    <div class="mb-3" id="tcpPortsPreview" style="display: none;">
                        <label class="form-label">Найденные TCP порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto; background-color: #3d3d3d; border-color: #555; color: #e0e0e0;">
                            <div id="tcpPortsPreviewContent"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadTcpPorts()" id="uploadTcpPortsBtn" disabled>Загрузить TCP порты</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="projectNmapUploadModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Загрузить порты для проекта (Nmap XML)</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="projectNmapUploadForm">
                    <div class="mb-3">
                        <label for="projectXmlFile" class="form-label">Файл Nmap XML</label>
                        <input type="file" class="form-control" id="projectXmlFile" accept=".xml" required>
                        <div class="form-text">Пример: nmap-ip.xml. Порты будут распределены по всем IP из файла</div>
                    </div>
                    <div class="mb-3" id="projectPortsPreview" style="display: none;">
                        <label class="form-label">Найденные порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto; background-color: #3d3d3d; border-color: #555; color: #e0e0e0;">
                            <div id="projectPortsPreviewContent"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadProjectPorts()" id="projectUploadPortsBtn" disabled>Загрузить порты</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="projectUdpUploadModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">UDP для проекта (udpx.txt)</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="projectUdpUploadForm">
                    <div class="mb-3">
                        <label for="projectUdpTxtFile" class="form-label">Файл udpx.txt</label>
                        <input type="file" class="form-control" id="projectUdpTxtFile" accept=".txt" required>
                        <div class="form-text">JSONL формат: одна запись на строку</div>
                    </div>
                    <div class="mb-3" id="projectUdpPortsPreview" style="display: none;">
                        <label class="form-label">Найденные UDP порты</label>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto; background-color: #3d3d3d; border-color: #555; color: #e0e0e0;">
                            <div id="projectUdpPortsPreviewContent"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-warning" onclick="uploadProjectUdpPorts()" id="projectUploadUdpPortsBtn" disabled>Загрузить UDP</button>
            </div>
        </div>
    </div>
 </div>

{% endblock %}

{% block scripts %}
<script>
let attackSurfaceData = {
    domains: [],
    cidrs: [],
    graph: { nodes: [], links: [] }
};

// Переменные для управления графом
let currentZoom = null;
let currentSvg = null;
let currentAttackSurfaceId = null;

// Делаем currentAttackSurfaceId доступным глобально
window.currentAttackSurfaceId = null;

function normalizeHost(x) {
    try {
        if (typeof x === 'string' && /^https?:\/\//i.test(x)) {
            const u = new URL(x);
            const h = (u.hostname || '').toLowerCase();
            return h.startsWith('www.') ? h.slice(4) : h;
        }
        const h = String(x || '').toLowerCase();
        return h.startsWith('www.') ? h.slice(4) : h;
    } catch (e) {
        const h = String(x || '').toLowerCase();
        return h.startsWith('www.') ? h.slice(4) : h;
    }
}
window.normalizeHost = normalizeHost;
function findWebsiteByHost(host) {
    try {
        const list = window.__websitesCache || [];
        const h = normalizeHost(host);
        for (const w of list) {
            try {
                const wu = new URL(w.url);
                const wh = normalizeHost(wu.hostname);
                if (wh === h) return w;
            } catch (e) {
                const wh = normalizeHost(w.url);
                if (wh === h) return w;
            }
        }
    } catch (e) {}
    return null;
}
window.findWebsiteByHost = findWebsiteByHost;

function openStatusPicker(ev, websiteId) {
    try { ev.preventDefault(); ev.stopPropagation(); } catch (e) {}
    try { window.__lastStatusBadge = ev.target; } catch (e) {}
    const existing = document.getElementById('statusPickerMenu');
    if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
    const menu = document.createElement('div');
    menu.id = 'statusPickerMenu';
    menu.style.position = 'absolute';
    menu.style.zIndex = '9999';
    menu.style.background = '#fff';
    menu.style.border = '1px solid rgba(0,0,0,0.15)';
    menu.style.borderRadius = '0.25rem';
    menu.style.boxShadow = '0 0.5rem 1rem rgba(0,0,0,0.15)';
    menu.style.padding = '0.25rem';
    const statuses = ['Не начат','В работе','Закрыт','Вернуться позже'];
    statuses.forEach(s => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'dropdown-item';
        btn.textContent = s;
        btn.style.display = 'block';
        btn.style.width = '100%';
        btn.style.textAlign = 'left';
        btn.onclick = function(e){ try{ e.stopPropagation(); }catch(_){} setWebsiteStatus(websiteId, s); if (menu && menu.parentNode) menu.parentNode.removeChild(menu); };
        menu.appendChild(btn);
    });
    document.body.appendChild(menu);
    const x = (ev.clientX || 0) + window.scrollX;
    const y = (ev.clientY || 0) + window.scrollY;
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    function closeOnOutside(e){
        if (!menu.contains(e.target)) {
            if (menu && menu.parentNode) menu.parentNode.removeChild(menu);
            document.removeEventListener('click', closeOnOutside, true);
        }
    }
    setTimeout(function(){ document.addEventListener('click', closeOnOutside, true); }, 0);
}

async function setWebsiteStatus(websiteId, status) {
    try {
        const r = await fetch(`/api/websites/${websiteId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status }) });
        await r.json();
    } catch (e) {}
    try {
        let cache = window.__websitesCache || [];
        const idx = cache.findIndex(w => Number(w.id) === Number(websiteId));
        if (idx >= 0) { cache[idx] = { ...cache[idx], status }; } else { cache.push({ id: websiteId, status }); }
        window.__websitesCache = cache;
    } catch (e) {}
    try {
        const cls = (status === 'В работе') ? 'bg-warning text-dark' : (status === 'Закрыт' ? 'bg-success' : (status === 'Вернуться позже' ? 'bg-info text-dark' : 'bg-secondary'));
        const el = window.__lastStatusBadge || document.querySelector(`span.badge[data-website-id="${Number(websiteId)}"]`);
        if (el) { el.textContent = status; el.className = `badge ${cls} ms-1`; }
    } catch (e) {}
    try {
        const ev = new CustomEvent('websiteUpdated', { detail: { id: Number(websiteId), status, origin: 'attack_surface' } });
        window.dispatchEvent(ev);
    } catch (e) {}
    try { localStorage.setItem('__websiteUpdated', JSON.stringify({ id: Number(websiteId), status, ts: Date.now() })); } catch (e) {}
}
function markDomainRowHasCard(domain, website) {
    try {
        const tbody = document.getElementById('attackSurfaceTableBody');
        if (!tbody) return;
        const dh = normalizeHost(domain);
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.forEach(tr => {
            const cells = tr.cells || [];
            const cell = cells[3];
            if (!cell) return;
            const strong = cell.querySelector('strong');
            if (!strong) return;
            const text = strong.textContent || '';
            if (normalizeHost(text) !== dh) return;
            tr.className = 'table-success';
            const st = website && website.status ? String(website.status) : 'Не начат';
            const cls = (st === 'В работе') ? 'bg-warning text-dark' : (st === 'Закрыт' ? 'bg-success' : (st === 'Вернуться позже' ? 'bg-info text-dark' : 'bg-secondary'));
            const base = '<strong>' + text + '</strong>';
            cell.innerHTML = base + ' <span class="badge bg-success ms-1">Есть карточка</span> ' + (website ? ('<span class="badge ' + cls + ' ms-1" data-website-id="' + Number(website.id) + '" style="cursor:pointer" title="Изменить статус" onclick="openStatusPicker(event, ' + Number(website.id) + ')">' + st + '</span>') : '');
            const actionsCell = cells[6];
            if (actionsCell) {
                try { actionsCell.innerHTML = renderScreenshotActionsForDomain(text); } catch (e) {}
            }
        });
        try {
            const host = normalizeHost(domain);
            const list = Array.isArray(attackSurfaceData.domainsWithSites) ? attackSurfaceData.domainsWithSites : [];
            if (!list.includes(host)) list.push(host);
            attackSurfaceData.domainsWithSites = list;
        } catch (e) {}
    } catch (e) {}
}
function loadD3AndThen(cb) {
    if (window.d3) { try { cb(); } catch (e) {} return; }
    if (window.__d3ReadyCallbacks) window.__d3ReadyCallbacks.push(cb); else window.__d3ReadyCallbacks = [cb];
    if (window.__d3Loading) return;
    window.__d3Loading = true;
    var s = document.createElement('script');
    s.src = 'https://d3js.org/d3.v7.min.js';
    s.onload = function() {
        window.__d3Loading = false;
        var cbs = window.__d3ReadyCallbacks || [];
        window.__d3ReadyCallbacks = [];
        cbs.forEach(function(fn){ try { fn(); } catch(e) {} });
    };
    s.onerror = function() {
        var s2 = document.createElement('script');
        s2.src = 'https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js';
        s2.onload = function() {
            window.__d3Loading = false;
            var cbs = window.__d3ReadyCallbacks || [];
            window.__d3ReadyCallbacks = [];
            cbs.forEach(function(fn){ try { fn(); } catch(e) {} });
        };
        s2.onerror = function() { window.__d3Loading = false; };
        document.head.appendChild(s2);
    };
    document.head.appendChild(s);
}

// Загрузка при старте страницы
document.addEventListener('DOMContentLoaded', function() {
    loadProjects();
    loadProjectsForSelect();
    try {
        window.addEventListener('storage', function(e){
            try {
                if (e.key === '__websiteUpdated' && e.newValue) {
                    const data = JSON.parse(e.newValue);
                    const id = Number(data.id);
                    const status = String(data.status||'');
                    let cache = window.__websitesCache || [];
                    const idx = cache.findIndex(w => Number(w.id) === id);
                    if (idx >= 0) cache[idx] = { ...cache[idx], status }; else cache.push({ id, status });
                    window.__websitesCache = cache;
                    const el = document.querySelector(`span.badge[data-website-id="${id}"]`);
                    if (el) {
                        el.textContent = status || 'Не начат';
                        const cls = (status === 'В работе') ? 'bg-warning text-dark' : (status === 'Закрыт' ? 'bg-success' : (status === 'Вернуться позже' ? 'bg-info text-dark' : 'bg-secondary'));
                        el.className = `badge ${cls} ms-1`;
                    } else {
                        updateAttackSurfaceTable();
                    }
                }
            } catch (e) {}
        });
    } catch (e) {}
});

// Обработчик загрузки файла
document.getElementById('domainsFile').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            document.getElementById('domainsPreview').value = content;
        };
        reader.readAsText(file);
    }
});

// Загрузка проектов
function loadProjects() {
    fetch('/api/projects')
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) {
                displayProjects(data);
            } else {
                document.getElementById('projectsList').innerHTML = 
                    '<div class="alert alert-danger">Ошибка загрузки проектов</div>';
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            document.getElementById('projectsList').innerHTML = 
                '<div class="alert alert-danger">Ошибка загрузки проектов</div>';
        });
}

function displayProjects(projects) {
    const container = document.getElementById('projectsList');
    if (projects.length === 0) {
        container.innerHTML = `
            <div class="text-center text-muted">
                <i class="fas fa-folder-open fa-3x mb-3"></i>
                <p>Нет проектов. Создайте проект на главной странице.</p>
            </div>
        `;
        return;
    }
    let html = '';
    projects.forEach(project => {
        html += `
            <div class="card mb-3">
                <div class="card-header">
                    <div class="d-flex align-items-center">
                        <h6 class="mb-0 me-3"><i class="fas fa-folder"></i> ${project.name}</h6>
                        <div id="project-${project.id}-stats" class="flex-grow-1 text-center"></div>
                        <div id="project-${project.id}-surfaces" class="d-flex flex-wrap align-items-center gap-2 ms-auto">
                            <div class="spinner-border spinner-border-sm" role="status"></div>
                            <span class="ms-2">Загрузка...</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    container.innerHTML = html;
    try { projects.forEach(p => loadAttackSurfaces(p.id)); } catch (e) {}
}

// Загрузка Attack Surface проекта
function loadAttackSurfaces(projectId) {
    const container = document.getElementById(`project-${projectId}-surfaces`);
    
    fetch(`/api/projects/${projectId}/attack-surfaces`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                displayAttackSurfaces(projectId, data.attack_surfaces);
            } else {
                container.innerHTML = '<div class="alert alert-danger">Ошибка загрузки Attack Surface</div>';
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            container.innerHTML = '<div class="alert alert-danger">Ошибка загрузки Attack Surface</div>';
        });
}

function displayAttackSurfaces(projectId, attackSurfaces) {
    const container = document.getElementById(`project-${projectId}-surfaces`);
    if (!container) return;
    if (!attackSurfaces || attackSurfaces.length === 0) {
        container.innerHTML = '<span class="text-muted">Нет Attack Surface</span>';
        return;
    }
    let html = '';
    attackSurfaces.forEach(as => {
        html += `
            <div class="btn-group btn-group-sm me-2 mb-2" role="group">
                <button class="btn btn-outline-primary" onclick="viewAttackSurface(${as.id}, '${as.name}')" title="${as.description || 'Без описания'}">
                    <i class="fas fa-eye"></i> ${as.name}
                </button>
                <button class="btn btn-outline-danger" onclick="deleteAttackSurface(${as.id})" title="Удалить">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
    });
    container.innerHTML = html;
    try { computeProjectStats(projectId, attackSurfaces); } catch (e) {}
}

async function computeProjectStats(projectId, attackSurfaces) {
    try {
        const graphs = await Promise.all((attackSurfaces || []).map(as => fetch(`/api/attack-surfaces/${as.id}/graph`).then(r => r.json()).catch(() => ({ success: false }))));
        const orgSet = new Set();
        const cidrSet = new Set();
        const ipSet = new Set();
        const domainSet = new Set();
        graphs.forEach(g => {
            if (g && g.success && g.graph && Array.isArray(g.graph.nodes)) {
                g.graph.nodes.forEach(n => {
                    if (n && n.type === 'cidr') { cidrSet.add(String(n.id)); if (n.organization) orgSet.add(String(n.organization)); }
                    else if (n && n.type === 'ip') { ipSet.add(String(n.id)); }
                    else if (n && n.type === 'domain') { domainSet.add(String(n.id)); }
                });
            }
        });
        const stats = { asn: orgSet.size, cidr: cidrSet.size, ip: ipSet.size, domain: domainSet.size };
        renderProjectStats(`project-${projectId}-stats`, stats);
    } catch (e) {}
}

function renderProjectStats(statsContainerId, stats) {
    try {
        const el = document.getElementById(statsContainerId);
        if (!el) return;
        const asn = Number(stats && stats.asn != null ? stats.asn : 0);
        const cidr = Number(stats && stats.cidr != null ? stats.cidr : 0);
        const ip = Number(stats && stats.ip != null ? stats.ip : 0);
        const dom = Number(stats && stats.domain != null ? stats.domain : 0);
        el.innerHTML = `
            <span class="badge" style="background-color:#ffc107;color:#212529;cursor:pointer" onclick="focusGraphOnOrganization()">ASN ${asn}</span>
            <span class="badge bg-danger">CIDR ${cidr}</span>
            <span class="badge bg-success">IP ${ip}</span>
            <span class="badge bg-primary">Домены ${dom}</span>
        `;
    } catch (e) {}
}

function focusGraphOnOrganization() {
    try {
        const orgs = Array.from((window.__orgLegendSet || new Set()));
        if (!orgs.length) return;
        const org = String(orgs[0]);
        window.__selectedOrganizationFilter = org;
        updateAttackSurfaceTable();
        updateGraph();
        if (window.currentSvg && window.currentZoom) {
            try { setTimeout(function(){ try { zoomToFitCurrentGraph(0.9); } catch (e) {} }, 200); } catch (e) {}
        }
        if (typeof renderOrgLegendOverlay === 'function' && window.currentSvg) renderOrgLegendOverlay(window.currentSvg);
    } catch (e) {}
}

// Загрузка проектов для селекта
function loadProjectsForSelect() {
    fetch('/api/projects')
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) {
                const select = document.getElementById('attackSurfaceProject');
                select.innerHTML = '<option value="">Выберите проект</option>';
                data.forEach(project => {
                    select.innerHTML += `<option value="${project.id}">${project.name}</option>`;
                });
            }
        });
}

// Создание Attack Surface
function createAttackSurface() {
    const name = document.getElementById('attackSurfaceName').value;
    const description = document.getElementById('attackSurfaceDescription').value;
    const projectId = document.getElementById('attackSurfaceProject').value;
    
    if (!name || !projectId) {
        alert('Пожалуйста, заполните все обязательные поля');
        return;
    }
    
    fetch(`/api/projects/${projectId}/attack-surfaces`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            name: name,
            description: description
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Attack Surface успешно создан!');
            bootstrap.Modal.getInstance(document.getElementById('createAttackSurfaceModal')).hide();
            document.getElementById('createAttackSurfaceForm').reset();
            loadProjects(); // Перезагрузить список проектов
        } else {
            alert('Ошибка создания Attack Surface: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при создании Attack Surface');
    });
}

// Просмотр Attack Surface
function viewAttackSurface(attackSurfaceId, name) {
    currentAttackSurfaceId = attackSurfaceId;
    window.currentAttackSurfaceId = attackSurfaceId;
    // Сбрасываем состояние графа и фильтры при переключении
    try { window.__lastGraphNodes = null; } catch (e) {}
    try { window.__lastGraphLinks = null; } catch (e) {}
    try { window.__selectedOrganizationFilter = null; } catch (e) {}
    try { window.__portsLegendSelectedCidrs = []; } catch (e) {}
    try { window.__portsLegendSelectedPorts = []; } catch (e) {}
    try { document.getElementById('scopeOnlyCheckbox').checked = false; } catch (e) {}
    try { window.__scopeOnly = false; } catch (e) {}
    try { localStorage.setItem('__currentAttackSurfaceId', String(attackSurfaceId)); } catch (e) {}
    document.getElementById('currentAttackSurfaceName').textContent = name;
    
    // Показать секции графа и данных
    document.getElementById('graphSection').style.display = 'block';
    document.getElementById('dataSection').style.display = 'block';
    
    // Загрузить граф
    loadAttackSurfaceGraph(attackSurfaceId);
    // Загрузить легенду портов для проекта
    try { loadPortsLegend([]); } catch (e) { if (!window.d3) loadD3AndThen(function(){ loadPortsLegend([]); }); }
    try { loadScopeState(); } catch (e) {}
    try { updateVhostCountBadge(); } catch (e) {}
}

// Загрузка графа Attack Surface
function loadAttackSurfaceGraph(attackSurfaceId) {
    try { document.getElementById('attackSurfaceGraph').innerHTML = ''; } catch (e) {}
    try { window.currentSvg = null; window.currentZoom = null; } catch (e) {}
    try { window.__orgLegendSet = new Set(); window.__orgLegendASNMap = new Map(); } catch (e) {}
    try { window.__cidrOrgCache = new Map(); } catch (e) {}
    // Загружаем граф и информацию о доменах с карточками параллельно
    Promise.all([
        fetch(`/api/attack-surfaces/${attackSurfaceId}/graph`).then(r => r.json()),
        fetch(`/api/attack-surfaces/${attackSurfaceId}/domains-with-sites`).then(r => r.json()),
        fetch(`/api/attack-surfaces/${attackSurfaceId}/domains`).then(r => r.json()),
        fetch(`/api/attack-surfaces/${attackSurfaceId}/ip-addresses`).then(r => r.json()),
        fetch(`/api/websites`).then(r => r.json())
    ])
    .then(([graphData, domainsData, dListData, ipData, websitesData]) => {
        if (graphData.success) {
            attackSurfaceData = graphData.graph;
            
            // Сохраняем информацию о доменах с карточками
            attackSurfaceData.domainsWithSites = domainsData.success ? domainsData.domains_with_sites : [];
            const ipIdMap = new Map();
            if (ipData && ipData.success && Array.isArray(ipData.ips)) {
                ipData.ips.forEach(x => { ipIdMap.set(String(x.ip), Number(x.id)); });
            }
            window.__ipIdMap = ipIdMap;
            window.__attackSurfaceDomainsList = dListData && dListData.success ? dListData.domains : [];
            window.__attackSurfaceIpsList = ipData && ipData.success ? ipData.ips : [];
            window.__websitesCache = Array.isArray(websitesData) ? websitesData : [];
            try { applyScopeFilterToGraph(); } catch (e) {}
            
            // Преобразуем nodes в domains и cidrs для таблицы
            attackSurfaceData.domains = [];
            attackSurfaceData.cidrs = [];
            
            if (attackSurfaceData.nodes) {
                attackSurfaceData.nodes.forEach(node => {
                    if (node.type === 'domain') {
                        const domainName = node.id.replace(/^https?:\/\//, '').toLowerCase();
                        const hasSite = attackSurfaceData.domainsWithSites.includes(domainName);
                        let ipCandidate = node.ip || null;
                        if (!ipCandidate && /^https?:\/\//i.test(node.id)) {
                            try {
                                const u = new URL(node.id);
                                const host = u.hostname;
                                if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) {
                                    ipCandidate = host;
                                }
                            } catch (e) {}
                        }
                        attackSurfaceData.domains.push({
                            domain: node.id,
                            ip: ipCandidate,
                            hasSite: hasSite
                        });
                        node.hasSite = hasSite;
                    } else if (node.type === 'cidr') {
                        attackSurfaceData.cidrs.push({
                            cidr: node.id
                        });
                    }
                });
            }
            
            // Преобразуем edges в links для совместимости с D3.js
    if (attackSurfaceData.edges) {
        attackSurfaceData.links = attackSurfaceData.edges.map(edge => ({
            source: edge.from,
            target: edge.to,
            label: edge.label,
            dashes: edge.dashes || false
        }));
    }
            updateAttackSurfaceDisplay();
            // Обновить легенду после загрузки графа
            try { loadPortsLegend(); } catch (e) { if (!window.d3) loadD3AndThen(function(){ loadPortsLegend(); }); }
        } else {
            console.log('Граф пуст или не найден');
            // Показать пустой граф
            attackSurfaceData = { domains: [], cidrs: [], nodes: [], links: [] };
            updateAttackSurfaceDisplay();
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Ошибка загрузки графа');
        });
}

// Удаление Attack Surface
function deleteAttackSurface(attackSurfaceId) {
    if (!confirm('Вы уверены, что хотите удалить этот Attack Surface?')) {
        return;
    }
    
    fetch(`/api/attack-surfaces/${attackSurfaceId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Attack Surface удален');
            loadProjects(); // Перезагрузить список проектов
            
            // Скрыть граф если удален текущий
            if (currentAttackSurfaceId === attackSurfaceId) {
                document.getElementById('graphSection').style.display = 'none';
                document.getElementById('dataSection').style.display = 'none';
                currentAttackSurfaceId = null;
                window.currentAttackSurfaceId = null;
            }
        } else {
            alert('Ошибка удаления: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при удалении');
    });
}

// Анализ attack surface
function analyzeAttackSurface() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    
    const domainsPreview = document.getElementById('domainsPreview').value.trim();
    const resolveDomains = document.getElementById('resolveDomains').checked;
    const detectCIDR = document.getElementById('detectCIDR').checked;
    
    if (!domainsPreview) {
        alert('Пожалуйста, загрузите файл с доменами или IP адресами');
        return;
    }
    
    const domains = domainsPreview.split('\n').filter(line => line.trim());
    
    fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/analyze`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            domains_and_ips: domains,
            resolve_domains: resolveDomains,
            detect_cidr: detectCIDR
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Перезагрузить граф
            loadAttackSurfaceGraph(currentAttackSurfaceId);
            
            // Закрыть модальное окно
            bootstrap.Modal.getInstance(document.getElementById('addDomainsModal')).hide();
            
            // Очистить форму
            document.getElementById('domainsPreview').value = '';
            document.getElementById('domainsFile').value = '';
            
            alert('Домены успешно добавлены в Attack Surface!');
        } else {
            alert('Ошибка анализа: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при анализе');
    });
}

// Обновление отображения attack surface
async function updateAttackSurfaceDisplay() {
    if (!currentAttackSurfaceId) {
        try { updateAttackSurfaceTable(); } catch (e) {}
        try { updateGraph(); } catch (e) {}
        return;
    }
    
    try {
        // Загружаем список доменов с ID
        const domainsResponse = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
        const domainsData = await domainsResponse.json();
        
        if (domainsData.success && attackSurfaceData.domains) {
            // Загружаем порты для каждого домена
            const domainsWithPorts = await Promise.all(
                attackSurfaceData.domains.map(async (domain) => {
                    try {
                        // Найти домен с ID
                        const domainWithId = domainsData.domains.find(d => d.domain === domain.domain);
                        if (domainWithId) {
                            const portsResponse = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains/${domainWithId.id}/ports`);
                            const portsData = await portsResponse.json();
                            return {
                                ...domain,
                                ip: domainWithId.ip || domain.ip,
                                ports: portsData.success ? portsData.ports : []
                            };
                        }
                        return { ...domain, ports: [] };
                    } catch (error) {
                        console.warn(`Ошибка загрузки портов для домена ${domain.domain}:`, error);
                        return { ...domain, ports: [] };
                    }
                })
            );
            
            attackSurfaceData.domains = domainsWithPorts;
            const ipPortsMap = new Map();
            attackSurfaceData.domains.forEach(d => {
                const ip = d.ip || 'Не определен';
                if (!ip || ip === 'Не определен') return;
                let set = ipPortsMap.get(ip);
                if (!set) { set = new Set(); ipPortsMap.set(ip, set); }
                (d.ports || []).forEach(p => {
                    if (p && p.port != null) {
                        const proto = (p.protocol || 'tcp').toLowerCase();
                        set.add(`${Number(p.port)}/${proto}`);
                    }
                });
            });
            const ipNodes = (attackSurfaceData.nodes || []).filter(n => n.type === 'ip');
            ipNodes.forEach(n => {
                const ip = n.id;
                if (!ipPortsMap.has(ip)) {
                    const set = new Set();
                    (String(n.ports_text || '')).split(',').forEach(s => {
                        const m = s.trim().match(/^([0-9]+)\/(tcp|udp)/i);
                        if (m) set.add(`${Number(m[1])}/${m[2].toLowerCase()}`);
                    });
                    if (set.size > 0) ipPortsMap.set(ip, set);
                }
            });
            window.__ipPortsMap = ipPortsMap;
            try {
                const ipRes = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses`);
                const ipData = await ipRes.json();
                if (ipData && ipData.success) window.__attackSurfaceIpsList = ipData.ips || [];
            } catch (e) {}
        }
    } catch (error) {
        console.warn('Ошибка загрузки портов:', error);
    }
    
    updateAttackSurfaceTable();
    try { updateGraph(); } catch (e) { if (!window.d3) loadD3AndThen(function(){ updateGraph(); }); }
}

try {
    window.addEventListener('websiteUpdated', function(ev){
        try {
            const data = ev.detail || {};
            let cache = window.__websitesCache || [];
            const idx = cache.findIndex(w => Number(w.id) === Number(data.id));
            if (idx >= 0) {
                cache[idx] = { ...cache[idx], status: data.status, url: data.url, name: data.name };
            } else {
                cache.push({ id: data.id, status: data.status, url: data.url, name: data.name });
            }
            window.__websitesCache = cache;
        } catch (e) {}
        try {
            const origin = (ev.detail && ev.detail.origin) || null;
            if (origin !== 'attack_surface') {
                updateAttackSurfaceTable();
            }
        } catch (e) {}
    });
} catch (e) {}

// Обновление единой таблицы Attack Surface данных
function updateAttackSurfaceTable() {
    const tbody = document.getElementById('attackSurfaceTableBody');
    
    // Проверяем наличие данных
    if ((!attackSurfaceData.domains || attackSurfaceData.domains.length === 0) && 
        (!attackSurfaceData.cidrs || attackSurfaceData.cidrs.length === 0)) {
        tbody.innerHTML = '<tr><td colspan="5" class="text-muted text-center">Данные не найдены</td></tr>';
        return;
    }
    
    let html = '';
    
    // Сортировка
    const sortState = window.__attackSurfaceSort || { key: 'cidr', dir: 'asc' };
    function cmp(a, b) {
        if (a == null && b == null) return 0;
        if (a == null) return 1;
        if (b == null) return -1;
        const sa = String(a).toLowerCase();
        const sb = String(b).toLowerCase();
        if (sa < sb) return sortState.dir === 'asc' ? -1 : 1;
        if (sa > sb) return sortState.dir === 'asc' ? 1 : -1;
        return 0;
    }
    function compareStatus(a, b) {
        const va = a == null ? 1e9 : Number(a);
        const vb = b == null ? 1e9 : Number(b);
        return sortState.dir === 'asc' ? (va - vb) : (vb - va);
    }
    function getDomainStatusCode(domainName) {
        try {
            const dList = window.__attackSurfaceDomainsList || [];
            const match = dList.find(x => String(x.domain) === String(domainName));
            return match && match.screenshot_status_code != null ? Number(match.screenshot_status_code) : null;
        } catch (e) { return null; }
    }
    function getIpStatusCode(ip) {
        try {
            const ipList = window.__attackSurfaceIpsList || [];
            const match = ipList.find(x => String(x.ip) === String(ip));
            return match && match.screenshot_status_code != null ? Number(match.screenshot_status_code) : null;
        } catch (e) { return null; }
    }
    function sortIps(ipArr, ipMap) {
        const arr = [...ipArr];
        if (sortState.key === 'status') {
            return arr.sort((ip1, ip2) => {
                const doms1 = ipMap.get(ip1) || [];
                const doms2 = ipMap.get(ip2) || [];
                const s1 = doms1.length ? Math.min(...doms1.map(d => getDomainStatusCode(d.domain)).map(v => v == null ? 1e9 : v)) : getIpStatusCode(ip1);
                const s2 = doms2.length ? Math.min(...doms2.map(d => getDomainStatusCode(d.domain)).map(v => v == null ? 1e9 : v)) : getIpStatusCode(ip2);
                return compareStatus(s1, s2) || cmp(ip1, ip2);
            });
        }
        return arr.sort((ip1, ip2) => cmp(ip1, ip2));
    }
    function sortDomains(domArr) {
        if (sortState.key === 'status') {
            return [...domArr].sort((d1, d2) => {
                const s1 = getDomainStatusCode(d1.domain);
                const s2 = getDomainStatusCode(d2.domain);
                return compareStatus(s1, s2) || cmp(d1.domain, d2.domain);
            });
        }
        return [...domArr].sort((d1, d2) => cmp(d1.domain, d2.domain));
    }

    // Создаем карту CIDR -> IP -> домены
    const cidrMap = new Map();
    const selectedPortsSet = new Set(window.__portsLegendSelectedPorts || []);
    const ipPortsMap = window.__ipPortsMap || new Map();
    const orgFilter = window.__selectedOrganizationFilter || null;
    const cidrFilter = null;
    const scopeOnly = !!window.__scopeOnly;
    let allowedIpsByOrg = null;
    if (orgFilter) {
        try {
            const nodes = attackSurfaceData.nodes || [];
            const nodesById = new Map(nodes.map(n => [n.id, n]));
            const contains = [...(attackSurfaceData.edges || []), ...(attackSurfaceData.links || [])].filter(e => (e.label === 'contains'));
            const ipByCidr = {};
            contains.forEach(e => {
                const fromId = e.from !== undefined ? e.from : ((e.source && typeof e.source === 'object') ? e.source.id : e.source);
                const toId = e.to !== undefined ? e.to : ((e.target && typeof e.target === 'object') ? e.target.id : e.target);
                const fromNode = nodesById.get(fromId);
                const toNode = nodesById.get(toId);
                if (fromNode && toNode) {
                    if (fromNode.type === 'cidr' && toNode.type === 'ip') {
                        if (!ipByCidr[fromId]) ipByCidr[fromId] = new Set();
                        ipByCidr[fromId].add(toId);
                    } else if (toNode.type === 'cidr' && fromNode.type === 'ip') {
                        if (!ipByCidr[toId]) ipByCidr[toId] = new Set();
                        ipByCidr[toId].add(fromId);
                    }
                }
            });
            const cidrOrgMap = window.__cidrOrgCache || new Map();
            const ipsAllowed = new Set();
            Object.keys(ipByCidr).forEach(cidrId => {
                const ov = cidrOrgMap.get(String(cidrId));
                const nodeCidr = nodesById.get(cidrId);
                const orgName = (nodeCidr && nodeCidr.organization ? String(nodeCidr.organization) : null) || (ov && ov.organization ? ov.organization : null);
                if (orgName && orgName === orgFilter) {
                    ipByCidr[cidrId].forEach(ipId => ipsAllowed.add(ipId));
                }
            });
            if (ipsAllowed.size > 0) {
                allowedIpsByOrg = ipsAllowed;
            }
        } catch (e) {
            allowedIpsByOrg = null;
        }
    }

    function renderIpPortsPreview(ip) {
        const set = ipPortsMap.get(ip);
        if (set && set.size) {
            const arr = Array.from(set).map(x => {
                const m = x.match(/^([0-9]+)\/(tcp|udp)$/i);
                return m ? { port: Number(m[1]), proto: m[2].toLowerCase(), s: x } : { port: 0, proto: 'tcp', s: x };
            }).sort((a,b)=> (a.port - b.port) || a.proto.localeCompare(b.proto));
            return `<small>${arr.map(e => e.s).join(', ')}</small>`;
        }
        const n = (attackSurfaceData.nodes || []).find(x => x.type === 'ip' && x.id === ip);
        if (n && n.ports_text) return `<small>${n.ports_text}</small>`;
        return '<span class="text-muted">-</span>';
    }
    
    // Обрабатываем CIDR блоки
    if (attackSurfaceData.cidrs && attackSurfaceData.cidrs.length > 0) {
        attackSurfaceData.cidrs.forEach(cidr => {
            const cidrValue = typeof cidr === 'string' ? cidr : cidr.cidr;
            if (!cidrMap.has(cidrValue)) {
                cidrMap.set(cidrValue, new Map());
            }
        });
    }
    try {
        const sel = document.getElementById('cidrFilterSelect');
        if (sel) {
            const existing = new Set(Array.from(sel.options).map(o => o.value));
            cidrMap.forEach((ipMap, cidr) => {
                const hasVisibleIp = Array.from(ipMap.keys()).some(ip => {
                    if (ip === 'Не определен') return false;
                    const ipInScope = isIpInScope(ip);
                    const hasDomainInScope = (ipMap.get(ip) || []).some(d => isHostInScope(d.domain));
                    return ipInScope || hasDomainInScope;
                });
                if (!hasVisibleIp) return;
                if (!existing.has(cidr)) {
                    const opt = document.createElement('option');
                    opt.value = cidr; opt.textContent = cidr;
                    sel.appendChild(opt);
                }
            });
        }
    } catch (e) {}
    
    // Обрабатываем домены и их IP
    if (attackSurfaceData.domains && attackSurfaceData.domains.length > 0) {
        attackSurfaceData.domains.forEach(domain => {
            let ip = domain.ip || null;
            if (!ip || ip === 'Не определен') {
                try {
                    if (typeof domain.domain === 'string' && /^https?:\/\//i.test(domain.domain)) {
                        const u = new URL(domain.domain);
                        const host = u.hostname;
                        if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) {
                            ip = host;
                        }
                    }
                } catch (e) {}
            }
            ip = ip || 'Не определен';
            if (scopeOnly) {
                try {
                    const okHost = isHostInScope(domain.domain);
                    const okIp = ip !== 'Не определен' && isIpInScope(ip);
                    if (!okHost && !okIp) return;
                } catch (e) {}
            }
            
            // Находим подходящий CIDR для IP (если домен представлен как URL с IP, ip придёт из API)
            let matchedCidr = 'Не определен';
            for (let [cidrValue] of cidrMap) {
                if (ip !== 'Не определен' && isIpInCidr(ip, cidrValue)) {
                    matchedCidr = cidrValue;
                    break;
                }
            }
            
            // Если CIDR не найден, но есть IP, создаем запись
            if (matchedCidr === 'Не определен' && ip !== 'Не определен') {
                matchedCidr = ip + '/32'; // Одиночный IP как /32
            }
            
            if (!cidrMap.has(matchedCidr)) {
                cidrMap.set(matchedCidr, new Map());
            }
            
            if (!cidrMap.get(matchedCidr).has(ip)) {
                cidrMap.get(matchedCidr).set(ip, []);
            }
            
            cidrMap.get(matchedCidr).get(ip).push(domain);
        });
    }
    // Добавляем IP-узлы без доменов как отдельные строки
    const ipNodes = (attackSurfaceData.nodes || []).filter(n => n.type === 'ip');
    ipNodes.forEach(n => {
        const ip = n.id;
        if (scopeOnly && !isIpInScope(ip)) {
            const hasDomainInScope = (attackSurfaceData.domains || []).some(d => (d.ip === ip) && isHostInScope(d.domain));
            if (!hasDomainInScope) return;
        }
        let matchedCidr = 'Не определен';
        for (let [cidrValue] of cidrMap) {
            if (isIpInCidr(ip, cidrValue)) { matchedCidr = cidrValue; break; }
        }
        if (matchedCidr === 'Не определен' && ip) {
            matchedCidr = ip + '/32';
        }
        if (!cidrMap.has(matchedCidr)) {
            cidrMap.set(matchedCidr, new Map());
        }
        if (!cidrMap.get(matchedCidr).has(ip)) {
            cidrMap.get(matchedCidr).set(ip, []);
        }
    });
    
    // Генерируем HTML для таблицы
    const visibleIps = new Set();
    const visibleDomains = new Set();
    const visibleIpStandalone = new Set();
    // Сортируем CIDR'ы
    let cidrsSorted = [...cidrMap.keys()].sort((c1, c2) => cmp(c1, c2));
    if (scopeOnly) {
        cidrsSorted = cidrsSorted.filter(cidr => {
            const ipMap = cidrMap.get(cidr);
            const hasVisibleIp = Array.from(ipMap.keys()).some(ip => {
                if (ip === 'Не определен') return false;
                const ipInScope = isIpInScope(ip);
                const hasDomainInScope = (ipMap.get(ip) || []).some(d => isHostInScope(d.domain));
                return ipInScope || hasDomainInScope;
            });
            return hasVisibleIp;
        });
    }
    for (let cidr of cidrsSorted) {
        const ipMap = cidrMap.get(cidr);
        let isFirstCidrRow = true;
        
        if (ipMap.size === 0) {
            // CIDR без IP
            html += `
                <tr>
                    <td><strong>${cidr}</strong></td>
                    <td class="text-muted">-</td>
                    <td class="text-muted">-</td>
                    <td class="text-muted">-</td>
                    <td>-</td>
                </tr>
            `;
        } else {
            const ipsSorted = sortIps(ipMap.keys(), ipMap);
            for (let ip of ipsSorted) {
                const domains = ipMap.get(ip);
                let isFirstIpRow = true;
                const ipHasSelected = selectedPortsSet.size === 0 ? true : (() => {
                    const s = ipPortsMap.get(ip);
                    if (!s) return false;
                    for (const p of selectedPortsSet) {
                        const needle = `${Number(p)}/`;
                        if ([...s].some(str => str.startsWith(needle))) return true;
                    }
                    return false;
                })();
                if (!ipHasSelected) {
                    continue;
                }
                if (allowedIpsByOrg && !allowedIpsByOrg.has(ip)) {
                    continue;
                }
                
                
                if (domains.length === 0) {
                    // IP без доменов
                    visibleIps.add(ip);
                    visibleIpStandalone.add(ip);
                    const ipId = (window.__ipIdMap && window.__ipIdMap.get(ip)) || null;
                    html += `
                        <tr>
                            <td>${isFirstCidrRow ? `<strong>${cidr}</strong>` : ''}</td>
                            <td><code>${ip}</code></td>
                            <td>${renderIpPortsPreview(ip)}</td>
                            <td class="text-muted">-</td>
                            <td>${renderScreenshotImageOnlyForIp(ip)}</td>
                            <td>${renderScreenshotStatusForIp(ip)}</td>
                            <td>${renderScreenshotActionsForIp(ip)}</td>
                        </tr>
                    `;
                    isFirstCidrRow = false;
                } else {
                    const domainsSorted = sortDomains(domains);
                    domainsSorted.forEach(domain => {
                        const rowClass = domain.hasSite ? 'table-success' : '';
                        const domainText = (() => {
                            const base = `<strong>${domain.domain}</strong>`;
                            const w = findWebsiteByHost(domain.domain);
                            const statusBadge = (() => {
                                const stSite = (() => {
                                    const rec = (window.__websitesCache||[]).find(x => Number(x.id) === Number(w && w.id));
                                    return rec && rec.status ? String(rec.status).trim() : null;
                                })();
                                const st = stSite || (w ? String(w.status||'').trim() : '') || 'Не начат';
                                const cls = st === 'В работе' ? 'bg-warning text-dark' : (st === 'Закрыт' ? 'bg-success' : (st === 'Вернуться позже' ? 'bg-info text-dark' : 'bg-secondary'));
                                return w ? ` <span class="badge ${cls} ms-1" data-website-id="${Number(w.id)}" style="cursor:pointer" title="Изменить статус" onclick="openStatusPicker(event, ${Number(w.id)})">${st}</span>` : '';
                            })();
                            const hasCard = domain.hasSite || !!w;
                            return hasCard ? `${base} <span class="badge bg-success ms-1">Есть карточка</span>${statusBadge}` : base + statusBadge;
                        })();
                        visibleIps.add(ip);
                        visibleDomains.add(domain.domain);
                        html += `
                            <tr class="${rowClass}">
                                <td>${isFirstCidrRow ? `<strong>${cidr}</strong>` : ''}</td>
                                <td>${isFirstIpRow ? `<code>${ip}</code>` : ''}</td>
                                <td>${renderIpPortsPreview(ip)}</td>
                                <td>${domainText}</td>
                                <td>${renderScreenshotImageOnlyForDomain(domain.domain)}</td>
                                <td>${renderScreenshotStatusForDomain(domain.domain)}</td>
                                <td>
                                    <button class="btn btn-sm btn-outline-primary me-1" onclick="showCreateSiteModal('${domain.domain}', '${domain.domain}')" title="Создать сайт">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                    ${renderScreenshotActionsForDomain(domain.domain)}
                                    <button class="btn btn-sm btn-outline-danger ms-1" onclick="deleteAttackSurfaceDomain('${domain.domain}')" title="Удалить">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </td>
                            </tr>
                        `;
                        isFirstCidrRow = false;
                        isFirstIpRow = false;
                    });
                }
            }
        }
    }
    
    tbody.innerHTML = html;
    try { applyAttackSurfaceSearch(); } catch (e) {}
    window.__visibleIps = Array.from(visibleIps);
    window.__visibleDomains = Array.from(visibleDomains);
    window.__visibleIpStandalone = Array.from(visibleIpStandalone);
}

// Функция для проверки, находится ли IP в CIDR
function isIpInCidr(ip, cidr) {
    try {
        const [network, prefixLength] = cidr.split('/');
        if (!prefixLength) return false;
        
        const ipParts = ip.split('.').map(Number);
        const networkParts = network.split('.').map(Number);
        
        if (ipParts.length !== 4 || networkParts.length !== 4) return false;
        
        const prefix = parseInt(prefixLength);
        const mask = (0xFFFFFFFF << (32 - prefix)) >>> 0;
        
        const ipInt = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
        const networkInt = (networkParts[0] << 24) + (networkParts[1] << 16) + (networkParts[2] << 8) + networkParts[3];
        
        return (ipInt & mask) === (networkInt & mask);
    } catch {
        return false;
    }
}

function showScopeModal() {
    try {
        if (!currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        const fileInput = document.getElementById('scopeFile');
        const preview = document.getElementById('scopePreview');
        if (fileInput) fileInput.value = '';
        if (preview) preview.value = '';
        if (fileInput && preview) {
            fileInput.onchange = async function() {
                try {
                    const f = this.files && this.files[0];
                    if (!f) { preview.value = ''; return; }
                    const lines = await parseScopeFile(f);
                    preview.value = lines.join('\n');
                } catch (e) { preview.value = ''; }
            };
        }
        new bootstrap.Modal(document.getElementById('scopeModal')).show();
    } catch (e) {
        alert('Не удалось открыть модальное окно Scope');
    }
}

function parseScopeFile(file) {
    return new Promise((resolve) => {
        try {
            const reader = new FileReader();
            reader.onload = () => {
                const text = String(reader.result || '').replace(/\r\n/g, '\n');
                const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
                resolve(lines);
            };
            reader.onerror = () => resolve([]);
            reader.readAsText(file);
        } catch (e) { resolve([]); }
    });
}

async function uploadScope() {
    try {
        if (!currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        const fileInput = document.getElementById('scopeFile');
        if (!fileInput || !fileInput.files || !fileInput.files[0]) { alert('Выберите файл'); return; }
        const preview = document.getElementById('scopePreview');
        const lines = await parseScopeFile(fileInput.files[0]);
        preview.value = lines.join('\n');
        const res = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/scope`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ items: lines })
        });
        if (!res.ok) {
            try {
                if (res.status === 404) { alert('Attack Surface не найден. Откройте Attack Surface и повторите.'); return; }
                const txt = await res.text();
                alert(`Ошибка загрузки scope: ${res.status} ${txt || ''}`);
                return;
            } catch (e) { alert('Ошибка загрузки scope'); return; }
        }
        const data = await res.json().catch(() => null);
        if (!data || !data.success) { alert(data && data.error ? `Ошибка загрузки scope: ${data.error}` : 'Ошибка загрузки scope'); return; }
        window.__scopeItems = Array.isArray(data.items) ? data.items : lines;
        window.__scopeOnly = true;
        try { localStorage.setItem(`__scopeOnly:${currentAttackSurfaceId}`, '1'); } catch (e) {}
        try { bootstrap.Modal.getInstance(document.getElementById('scopeModal')).hide(); } catch (e) {}
        try { document.getElementById('scopeOnlyCheckbox').checked = true; } catch (e) {}
        try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) { updateAttackSurfaceDisplay(); }
    } catch (e) { alert('Ошибка загрузки scope'); }
}

function loadScopeState() {
    try {
        if (!currentAttackSurfaceId) return;
        const key = `__scopeOnly:${currentAttackSurfaceId}`;
        const stored = (function(){ try { return localStorage.getItem(key); } catch(e) { return null; } })();
        fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/scope`)
            .then(res => res.ok ? res.json() : null)
            .then(data => {
                if (data && data.success) {
                    window.__scopeItems = Array.isArray(data.items) ? data.items : [];
                    if (stored != null) {
                        window.__scopeOnly = stored === '1';
                        try { document.getElementById('scopeOnlyCheckbox').checked = window.__scopeOnly; } catch (e) {}
                    } else {
                        window.__scopeOnly = !!data.scope_only;
                        try { document.getElementById('scopeOnlyCheckbox').checked = !!data.scope_only; } catch (e) {}
                    }
                }
            })
            .catch(() => {});
    } catch (e) {}
}

function toggleScopeOnly(checked) {
    try {
        if (checked && (!window.__scopeItems || window.__scopeItems.length === 0)) {
            alert('Загрузите файл scope');
            document.getElementById('scopeOnlyCheckbox').checked = false;
            try { if (currentAttackSurfaceId) localStorage.setItem(`__scopeOnly:${currentAttackSurfaceId}`, '0'); } catch (e) {}
            return;
        }
        window.__scopeOnly = !!checked;
        try { if (currentAttackSurfaceId) localStorage.setItem(`__scopeOnly:${currentAttackSurfaceId}`, checked ? '1' : '0'); } catch (e) {}
        try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) { updateAttackSurfaceDisplay(); }
    } catch (e) {}
}

function normalizeRootDomain(host) {
    try {
        let h = String(host || '').trim().toLowerCase();
        h = h.replace(/^https?:\/\//, '').split('/')[0];
        h = h.replace(/^www\./, '');
        const parts = h.split('.');
        if (parts.length >= 2) return parts.slice(parts.length - 2).join('.');
        return h;
    } catch (e) { return String(host||''); }
}

function normalizeHost(hostOrUrl) {
    try {
        let h = String(hostOrUrl || '').trim().toLowerCase();
        if (/^https?:\/\//i.test(h)) {
            try { h = new URL(h).hostname; } catch (e) { h = h.replace(/^https?:\/\//, '').split('/')[0]; }
        }
        h = h.replace(/^www\./, '');
        return h;
    } catch (e) { return String(hostOrUrl||''); }
}

function isIpInScope(ip) {
    try {
        const items = window.__scopeItems || [];
        return items.some(x => /^\d+\.\d+\.\d+\.\d+$/.test(String(x)) && String(x).trim() === String(ip).trim());
    } catch (e) { return false; }
}

function isHostInScope(hostOrUrl) {
    try {
        const items = window.__scopeItems || [];
        const root = normalizeRootDomain(hostOrUrl);
        return items.some(x => !/^\d+\.\d+\.\d+\.\d+$/.test(String(x)) && normalizeRootDomain(String(x)) === root);
    } catch (e) { return false; }
}

function applyScopeFilterToGraph() {
    try {
        if (!window.__scopeOnly) return;
        // set flag so updateGraph uses it
    } catch (e) {}
}
// Обновление графа
function updateGraph() {
    if (!window.d3) { loadD3AndThen(updateGraph); return; }
    const container = document.getElementById('attackSurfaceGraph');
    container.innerHTML = '';
    
    if (!attackSurfaceData.nodes || attackSurfaceData.nodes.length === 0) {
        container.innerHTML = `
            <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                <div class="text-center">
                    <i class="fas fa-network-wired fa-3x mb-3"></i>
                    <p>Граф пуст</p>
                </div>
            </div>
        `;
        // Скрываем элементы управления
        document.getElementById('graphControls').style.display = 'none';
        return;
    }
    
    // Создание SVG для D3.js графа
    const width = container.clientWidth;
    const height = 600;
    
    const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);

        window.currentSvg = svg;  // Обновляем глобальную ссылку на новый SVG
    
    // Добавление группы для масштабирования и перемещения
    const g = svg.append('g');
    
    // Настройка zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on('zoom', function(event) {
            g.attr('transform', event.transform);
        });
    
    svg.call(zoom);
    
    // Сохраняем ссылки для управления
    currentZoom = zoom;
    currentSvg = svg;
    window.currentSvg = svg;
    window.currentZoom = zoom;
    
    // Показываем элементы управления
    document.getElementById('graphControls').style.display = 'block';
    
    // Встроенная легенда будет отрисована после построения графа
    
    // Проверяем наличие данных
    let nodes = (window.__lastGraphNodes && Array.isArray(window.__lastGraphNodes) && window.__lastGraphNodes.length)
        ? window.__lastGraphNodes.slice()
        : (attackSurfaceData.nodes || []);
    let links = (window.__lastGraphLinks && Array.isArray(window.__lastGraphLinks) && window.__lastGraphLinks.length)
        ? window.__lastGraphLinks.slice()
        : (attackSurfaceData.links || []);

    // По умолчанию скрываем домены только если нет сохраненного состояния графа
    if (!window.__lastGraphNodes || !window.__lastGraphNodes.length) {
        try {
            const keepIds = new Set(nodes.filter(n => n.type !== 'domain').map(n => n.id));
            const origNodes = nodes;
            nodes = origNodes.filter(n => keepIds.has(n.id));
            links = links.filter(l => {
                const sId = (l.source && typeof l.source === 'object') ? l.source.id : l.source;
                const tId = (l.target && typeof l.target === 'object') ? l.target.id : l.target;
                return keepIds.has(sId) && keepIds.has(tId);
            });
        } catch (e) {}
    }
    const scopeOnly = !!window.__scopeOnly;
    if (scopeOnly) {
        const inScopeIps = new Set(nodes.filter(n => n.type === 'ip' && isIpInScope(n.id)).map(n => n.id));
        const inScopeDomains = new Set(nodes.filter(n => n.type === 'domain' && isHostInScope(n.id)).map(n => n.id));
        const ipNeeded = new Set(inScopeIps);
        nodes.forEach(n => { if (n.type === 'domain' && inScopeDomains.has(n.id) && n.ip) ipNeeded.add(n.ip); });
        const domainNeeded = new Set(nodes.filter(n => n.type === 'domain' && n.ip && ipNeeded.has(n.ip)).map(n => n.id));
        const cidrNeeded = new Set();
        const containsLinks = (attackSurfaceData.edges || []).concat(attackSurfaceData.links || []).filter(e => (e.label === 'contains'));
        containsLinks.forEach(e => {
            const fromId = e.from !== undefined ? e.from : ((e.source && typeof e.source === 'object') ? e.source.id : e.source);
            const toId = e.to !== undefined ? e.to : ((e.target && typeof e.target === 'object') ? e.target.id : e.target);
            const isFromCidr = nodes.some(n => n.id === fromId && n.type === 'cidr');
            const isToCidr = nodes.some(n => n.id === toId && n.type === 'cidr');
            const ipId = isFromCidr ? toId : (isToCidr ? fromId : null);
            const cidrId = isFromCidr ? fromId : (isToCidr ? toId : null);
            if (ipId && cidrId && ipNeeded.has(ipId)) cidrNeeded.add(cidrId);
        });
        const visibleNodeIds = new Set([...ipNeeded, ...inScopeDomains, ...domainNeeded, ...cidrNeeded]);
        nodes = nodes.filter(n => visibleNodeIds.has(n.id));
        links = links.filter(l => {
            const sId = (l.source && typeof l.source === 'object') ? l.source.id : l.source;
            const tId = (l.target && typeof l.target === 'object') ? l.target.id : l.target;
            return visibleNodeIds.has(sId) && visibleNodeIds.has(tId);
        });
    }
    const orgFilter = window.__selectedOrganizationFilter || null;
    if (orgFilter) {
        const allowedIds = new Set();
        const cidrIds = new Set((nodes.filter(n => n.type === 'cidr').map(n => n.id)));
        const nodesByIdLocal = new Map(nodes.map(n => [n.id, n]));
        const contains = [...(attackSurfaceData.edges || []), ...(attackSurfaceData.links || [])].filter(e => (e.label === 'contains'));
        const ipByCidr = {};
        contains.forEach(e => {
            const fromId = e.from !== undefined ? e.from : ((e.source && typeof e.source === 'object') ? e.source.id : e.source);
            const toId = e.to !== undefined ? e.to : ((e.target && typeof e.target === 'object') ? e.target.id : e.target);
            const fromNode = nodesByIdLocal.get(fromId);
            const toNode = nodesByIdLocal.get(toId);
            if (fromNode && toNode) {
                if (fromNode.type === 'cidr' && toNode.type === 'ip') {
                    if (!ipByCidr[fromId]) ipByCidr[fromId] = new Set();
                    ipByCidr[fromId].add(toId);
                } else if (toNode.type === 'cidr' && fromNode.type === 'ip') {
                    if (!ipByCidr[toId]) ipByCidr[toId] = new Set();
                    ipByCidr[toId].add(fromId);
                }
            }
        });
        const cidrToOrg = new Map();
        const cidrOverlaysData = window.__cidrOrgCache || new Map();
        nodes.filter(n => n.type === 'cidr').forEach(n => {
            const ov = cidrOverlaysData.get(n.id);
            const orgName = (n.organization ? String(n.organization) : null) || (ov && ov.organization ? ov.organization : null);
            if (orgName) cidrToOrg.set(n.id, orgName);
        });
        Object.keys(ipByCidr).forEach(cidrId => {
            const orgName = cidrToOrg.get(cidrId);
            if (orgName && orgName === orgFilter) {
                allowedIds.add(cidrId);
                ipByCidr[cidrId].forEach(ipId => allowedIds.add(ipId));
                nodes.forEach(n => { if (n.type === 'domain' && n.ip && ipByCidr[cidrId].has(n.ip)) allowedIds.add(n.id); });
            }
        });
        if (allowedIds.size > 0) {
            nodes = nodes.filter(n => allowedIds.has(n.id));
            links = links.filter(l => {
                const sId = (l.source && typeof l.source === 'object') ? l.source.id : l.source;
                const tId = (l.target && typeof l.target === 'object') ? l.target.id : l.target;
                return allowedIds.has(sId) && allowedIds.has(tId);
            });
        }
    }
    // Сохраняем текущий видимые узлы/связи для оверлеев (легенды и т.п.)
    try { window.__lastGraphNodes = nodes; window.__lastGraphLinks = links; } catch (e) {}
    // Инициализация узлов оставляем как раньше, без принудительного задания случайных координат
    
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => {
            if (d.label === 'contains') return 120;
            if (d.label === 'same_cidr') return 80;
            return 150;
        }).strength(d => d.label === 'contains' ? 0.7 : 0.5))
        .force('charge', d3.forceManyBody().strength(-800))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));
    
    // Добавление связей
    const link = g.append('g')
        .selectAll('line')
        .data(links)
        .enter().append('line')
        .attr('stroke', d => {
            if (d.label === 'same_cidr') return '#6c757d';
            if (d.label === 'contains') {
                const targetId = (d.target && typeof d.target === 'object') ? d.target.id : d.target;
                const ipNode = nodes.find(n => n.id === targetId && n.type === 'ip');
                const hasPorts = ipNode && ipNode.ports_text && ipNode.ports_text.trim().length > 0;
                const hasDomain = nodes.some(n => n.type === 'domain' && n.ip === (ipNode ? ipNode.id : null));
                return hasPorts && !hasDomain ? '#ff6f00' : '#999';
            }
            return '#999';
        })
        .attr('stroke-opacity', d => {
            if (d.label === 'same_cidr') return 0.4;
            if (d.label === 'contains') {
                const targetId = (d.target && typeof d.target === 'object') ? d.target.id : d.target;
                const ipNode = nodes.find(n => n.id === targetId && n.type === 'ip');
                const hasPorts = ipNode && ipNode.ports_text && ipNode.ports_text.trim().length > 0;
                const hasDomain = nodes.some(n => n.type === 'domain' && n.ip === (ipNode ? ipNode.id : null));
                return hasPorts && !hasDomain ? 0.9 : 0.65;
            }
            return 0.6;
        })
        .attr('stroke-width', d => d.label === 'same_cidr' ? 1 : 2)
        .attr('stroke-dasharray', d => d.dashes ? '5,5' : null);
    
    // Добавление узлов
    const node = g.append('g')
        .selectAll('circle')
        .data(nodes)
        .enter().append('circle')
        .attr('r', d => {
            if (d.type === 'cidr') return 20;
            if (d.type === 'ip') return 12;
            return 10;
        })
        .attr('fill', d => {
            if (d.type === 'cidr') return '#dc3545';
            if (d.type === 'ip') return '#28a745';
            if (d.type === 'domain') {
                return d.hasSite ? '#198754' : '#0d6efd'; // Зеленый для доменов с карточками
            }
            return '#6c757d';
        })
        .attr('stroke', d => {
            if (d.type === 'domain' && d.hasSite) {
                return '#ffc107'; // Желтая обводка для доменов с карточками
            }
            return '#fff';
        })
        .attr('stroke-width', d => {
            if (d.type === 'domain' && d.hasSite) {
                return 3; // Толще обводка для доменов с карточками
            }
            return 2;
        })
        .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
        .on('end', dragended))
        .on('click', function(event, d) {
            if (d.type === 'domain') {
                showCreateSiteModal(d.id, d.id);
            } else if (d.type === 'ip') {
                event.preventDefault();
                event.stopPropagation();
                showIpContextMenu(d, event.pageX, event.pageY);
            } else if (d.type === 'cidr') {
                // Показать контекстное меню для CIDR
                event.preventDefault();
                event.stopPropagation();
                showCidrContextMenu(d, event.pageX, event.pageY);
            }
        });
    
    // Добавление подписей
    const text = g.append('g')
        .selectAll('g')
        .data(nodes)
        .enter().append('g');
    
    // Обработка многострочных подписей и рендер портов под IP-узлами
    text.each(function(d) {
        const textGroup = d3.select(this);
        const rawLines = (d.label || '').split('\n');
        // Убираем IP из подписи доменных узлов (если пришло в скобках)
        const lines = rawLines.filter(line => !(d.type === 'domain' && /^\(.+\)$/.test(line.trim())));

        // Основные подписи над узлом
        lines.forEach((line, i) => {
            textGroup.append('text')
                .text(line)
                .attr('font-size', i === 0 ? '12px' : '10px')
                .attr('fill', i === 0 ? '#e0e0e0' : '#b0b0b0')
                .attr('text-anchor', 'middle')
                .attr('dy', -20 + (i * 12));
        });

        if (d.type === 'ip') {
            const domainsCount = (() => {
                try {
                    const allNodes = attackSurfaceData.nodes || [];
                    return allNodes.filter(n => n.type === 'domain' && n.ip === d.id).length;
                } catch (e) { return 0; }
            })();
            if (domainsCount > 0) {
                const badge = textGroup.append('g')
                    .attr('class', 'ip-domain-count')
                    .attr('transform', 'translate(4, -4)');
                badge.append('circle')
                    .attr('r', 6)
                    .attr('fill', '#ffc107')
                    .attr('stroke', '#212529')
                    .attr('stroke-width', 1);
                badge.append('text')
                    .text(String(domainsCount))
                    .attr('font-size', '9px')
                    .attr('fill', '#212529')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em');
            }

            const portsText = String(d.ports_text || '').trim();
            if (portsText.length > 0) {
                const portsGroup = textGroup.append('g')
                    .attr('class', 'ip-ports')
                    .attr('transform', 'translate(0, 22)');
                const t = portsGroup.append('text')
                    .text(portsText)
                    .attr('font-size', '10px')
                    .attr('fill', '#e0e0e0')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em');
                try {
                    const bbox = t.node().getBBox();
                    portsGroup.insert('rect', 'text')
                        .attr('x', -bbox.width / 2 - 8)
                        .attr('y', -bbox.height / 2 - 4)
                        .attr('width', bbox.width + 16)
                        .attr('height', bbox.height + 8)
                        .attr('rx', 6)
                        .attr('ry', 6)
                        .attr('fill', '#2f2f2f')
                        .attr('stroke', '#555')
                        .attr('stroke-width', 1);
                } catch (e) {}
            }
        }
    });

    // CIDR overlay: окружность и подписи ASN/ORG над CIDR узлом
    const cidrOverlayGroup = g.append('g').attr('class', 'cidr-overlay');
    const cidrOverlays = {};
    const nodesById = new Map(nodes.map(n => [n.id, n]));
    const containsEdges = (attackSurfaceData.edges || []).filter(e => e.label === 'contains');
    const containsLinks = (attackSurfaceData.links || []).filter(e => e.label === 'contains');
    const ipByCidr = {};
    [...containsEdges, ...containsLinks].forEach(e => {
        const fromId = e.from !== undefined ? e.from : ((e.source && typeof e.source === 'object') ? e.source.id : e.source);
        const toId = e.to !== undefined ? e.to : ((e.target && typeof e.target === 'object') ? e.target.id : e.target);
        const fromNode = nodesById.get(fromId);
        const toNode = nodesById.get(toId);
        if (fromNode && toNode) {
            if (fromNode.type === 'cidr' && toNode.type === 'ip') {
                if (!ipByCidr[fromId]) ipByCidr[fromId] = new Set();
                ipByCidr[fromId].add(toId);
            } else if (toNode.type === 'cidr' && fromNode.type === 'ip') {
                if (!ipByCidr[toId]) ipByCidr[toId] = new Set();
                ipByCidr[toId].add(fromId);
            }
        }
    });
    const cidrMembers = {};
    Object.keys(ipByCidr).forEach(cidrId => {
        const ipsSet = ipByCidr[cidrId];
        const arr = [];
        nodes.forEach(n => {
            if (n.type === 'ip' && ipsSet.has(n.id)) arr.push(n);
            else if (n.type === 'domain' && n.ip && ipsSet.has(n.ip)) arr.push(n);
        });
        cidrMembers[cidrId] = arr;
    });

    function renderCidrOverlayForNode(nodeData) {
        try {
            const id = nodeData.id;
            if (cidrOverlays[id]) return; // уже отрисовано
            const overlay = cidrOverlayGroup.append('g').attr('data-cidr', id);
            // базовая окружность (чуть больше) и отступы, чтобы текст не сливался с CIDR
            const circle = overlay.append('circle')
                .attr('r', 44)
                .attr('fill', 'none')
                .attr('stroke', '#ff4081')
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.9);
            // заглушка текста
            const t1 = overlay.append('text')
                .attr('font-size', '11px')
                .attr('fill', '#ffd1dc')
                .attr('text-anchor', 'middle')
                .attr('dy', -58)
                .text('ASN: ...');
            const t2 = overlay.append('text')
                .attr('font-size', '11px')
                .attr('fill', '#f8f9fa')
                .attr('text-anchor', 'middle')
                .attr('dy', -44)
                .text('Network: ...');
            const t3 = overlay.append('text')
                .attr('font-size', '11px')
                .attr('fill', '#f8f9fa')
                .attr('text-anchor', 'middle')
                .attr('dy', -30)
                .text('Org: ...');
            cidrOverlays[id] = { g: overlay, c: circle, t1, t2, t3, r: 44, cx: 0, cy: 0 };
            // загрузка данных
            fetch(`/api/cidr/asn-info?cidr=${encodeURIComponent(id)}${currentAttackSurfaceId ? '&attack_surface_id=' + currentAttackSurfaceId : ''}`)
                .then(r => r.json())
                .then(data => {
                    if (!data || data.error) return;
                    t1.text(`ASN: ${data.asn || '—'}`);
                    t2.text(`Network: ${data.network_name || data.prefix || '—'}`);
                    t3.text(`Org: ${data.organization || '—'}`);
                    try {
                        if (data.organization) {
                            if (!window.__orgLegendSet) window.__orgLegendSet = new Set();
                            window.__orgLegendSet.add(String(data.organization));
                            if (!window.__orgLegendASNMap) window.__orgLegendASNMap = new Map();
                            window.__orgLegendASNMap.set(String(data.organization), String(data.asn || ''));
                            if (!window.__cidrOrgCache) window.__cidrOrgCache = new Map();
                            window.__cidrOrgCache.set(String(id), { organization: String(data.organization), asn: String(data.asn || '') });
                            if (typeof renderOrgLegendOverlay === 'function' && window.currentSvg) renderOrgLegendOverlay(window.currentSvg);
                        }
                    } catch (e) {}
                })
                .catch(() => {});
        } catch (e) {}
    }

    function refreshCidrOverlayData(cidrId) {
        try {
            const ov = cidrOverlays[cidrId];
            if (!ov) return;
            fetch(`/api/cidr/asn-info?cidr=${encodeURIComponent(cidrId)}${currentAttackSurfaceId ? '&attack_surface_id=' + currentAttackSurfaceId : ''}`)
                .then(r => r.json())
                .then(data => {
                    if (!data || data.error) return;
                    ov.t1.text(`ASN: ${data.asn || '—'}`);
                    ov.t2.text(`Network: ${data.network_name || data.prefix || '—'}`);
                    ov.t3.text(`Org: ${data.organization || '—'}`);
                    try {
                        if (data.organization) {
                            if (!window.__orgLegendSet) window.__orgLegendSet = new Set();
                            window.__orgLegendSet.add(String(data.organization));
                            if (!window.__orgLegendASNMap) window.__orgLegendASNMap = new Map();
                            window.__orgLegendASNMap.set(String(data.organization), String(data.asn || ''));
                            if (!window.__cidrOrgCache) window.__cidrOrgCache = new Map();
                            window.__cidrOrgCache.set(String(cidrId), { organization: String(data.organization), asn: String(data.asn || '') });
                            if (typeof renderOrgLegendOverlay === 'function' && window.currentSvg) renderOrgLegendOverlay(window.currentSvg);
                        }
                    } catch (e) {}
                })
                .catch(() => {});
        } catch (e) {}
    }

    // отрисовать overlays для всех CIDR
    nodes.filter(n => n.type === 'cidr').forEach(renderCidrOverlayForNode);
    
    simulation.on('tick', () => {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
        
        node
            .attr('cx', d => d.x)
            .attr('cy', d => d.y);
        
        text
            .attr('transform', d => `translate(${d.x}, ${d.y})`);
        // Без дополнительной пост-коллизии — как было ранее

        // позиционирование CIDR overlays над узлом
        Object.keys(cidrOverlays).forEach(cidrId => {
            const ov = cidrOverlays[cidrId];
            const members = cidrMembers[cidrId] || [];
            let cx = 0, cy = 0, r = 60;
            const cidrNode = nodes.find(n => n.type === 'cidr' && n.id === cidrId);
            if (cidrNode) { cx = cidrNode.x; cy = cidrNode.y; }
            if (members.length > 0) {
                let maxNodeRadius = 0;
                let maxDist = 0;
                members.forEach(m => {
                    const rr = m.type === 'ip' ? 12 : (m.type === 'domain' ? 10 : 10);
                    if (typeof m.x === 'number' && typeof m.y === 'number' && typeof cidrNode?.x === 'number' && typeof cidrNode?.y === 'number') {
                        const dx = m.x - cidrNode.x;
                        const dy = m.y - cidrNode.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + rr;
                        if (dist > maxDist) maxDist = dist;
                    }
                    if (rr > maxNodeRadius) maxNodeRadius = rr;
                });
                const minRadius = 46;
                r = Math.max(maxDist + 12, minRadius);
            } else {
                r = 46;
            }
            ov.g.attr('transform', `translate(${cx}, ${cy})`);
            let labelHalfWidth = 0;
            try {
                [ov.t1, ov.t2, ov.t3].forEach(t => {
                    const bb = t && t.node && t.node();
                    if (bb && bb.getBBox) {
                        const b = bb.getBBox();
                        labelHalfWidth = Math.max(labelHalfWidth, (b.width || 0) / 2);
                    }
                });
            } catch (e) {}
            const margin = 18;
            const finalR = Math.max(r, labelHalfWidth + 12);
            ov.c.attr('r', finalR + margin);
            ov.t1.attr('x', 0).attr('y', -finalR + 10);
            ov.t2.attr('x', 0).attr('y', -finalR + 24);
            ov.t3.attr('x', 0).attr('y', -finalR + 38);
        });
    });
    
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    try { renderPortsLegendOverlay(svg); } catch (e) { console.error('Ошибка легенды портов:', e); }
    try { renderOrgLegendOverlay(svg); } catch (e) { console.error('Ошибка легенды организаций:', e); }
}

// ===== CIDR контекстное меню и вывод списков =====
let currentCidrNode = null;

function showCidrContextMenu(node, pageX, pageY) {
    try {
        const menu = document.getElementById('cidrContextMenu');
        currentCidrNode = node;
        // Позиционируем меню
        menu.style.left = pageX + 'px';
        menu.style.top = pageY + 'px';
        menu.style.display = 'block';

        // Обработчики пунктов меню
        const getIpsItem = menu.querySelector('[data-action="get_ips"]');
        const getDomainsItem = menu.querySelector('[data-action="get_domains"]');
        const uploadUdpItem = menu.querySelector('[data-action="upload_udp"]');
        const uploadTcpItem = menu.querySelector('[data-action="upload_tcp"]');
        const getAsnItem = menu.querySelector('[data-action="get_asn"]');

        getIpsItem.onclick = function(e) {
            e.stopPropagation();
            const ips = getIpsForCidr(currentCidrNode.id);
            renderCidrResultsList('IP адреса', currentCidrNode.id, ips);
            hideCidrContextMenu();
        };

        getDomainsItem.onclick = function(e) {
            e.stopPropagation();
            const ips = getIpsForCidr(currentCidrNode.id);
            const domains = getDomainsForIps(ips);
            renderCidrResultsList('Домены', currentCidrNode.id, domains);
            hideCidrContextMenu();
        };

        uploadUdpItem.onclick = function(e) {
            e.stopPropagation();
            // Без выбора IP: просто открываем модал, очистив предыдущий предпросмотр
            document.getElementById('uploadUdpPortsForm').reset();
            document.getElementById('udpPortsPreview').style.display = 'none';
            document.getElementById('uploadUdpPortsBtn').disabled = true;
            new bootstrap.Modal(document.getElementById('uploadUdpPortsModal')).show();
            hideCidrContextMenu();
        };

        uploadTcpItem.onclick = function(e) {
            e.stopPropagation();
            document.getElementById('uploadTcpPortsForm').reset();
            document.getElementById('tcpPortsPreview').style.display = 'none';
            document.getElementById('uploadTcpPortsBtn').disabled = true;
            new bootstrap.Modal(document.getElementById('uploadTcpPortsModal')).show();
            hideCidrContextMenu();
        };

        getAsnItem.onclick = function(e) {
            e.stopPropagation();
            try {
                const cidrVal = currentCidrNode.id;
                const card = document.getElementById('cidrResultsCard');
                const title = document.getElementById('cidrResultsTitle');
                const text = document.getElementById('cidrResultsText');
                title.textContent = `ASN/Организация для ${cidrVal}`;
                text.value = 'Загрузка...';
                card.style.display = 'block';
                fetch(`/api/cidr/asn-info?cidr=${encodeURIComponent(cidrVal)}${currentAttackSurfaceId ? '&attack_surface_id=' + currentAttackSurfaceId : ''}`)
                    .then(r => r.json())
                    .then(data => {
                        if (!data || data.error) {
                            text.value = `Ошибка: ${data && data.error ? data.error : 'неизвестная ошибка'}`;
                            return;
                        }
                        const lines = [];
                        lines.push(`CIDR: ${data.cidr || cidrVal}`);
                        if (data.prefix) lines.push(`Префикс: ${data.prefix}`);
                        if (data.asn) lines.push(`ASN: ${data.asn}`);
                        if (data.organization) lines.push(`Организация: ${data.organization}`);
                        if (data.network_name) lines.push(`Сеть: ${data.network_name}`);
                        if (data.rir) lines.push(`RIR: ${data.rir}`);
                        if (data.source) lines.push(`Источник: ${data.source}`);
                        text.value = lines.length ? lines.join('\n') : 'Данные не найдены';
                        refreshCidrOverlayData(cidrVal);
                        try {
                            if (data.organization) {
                                if (!window.__orgLegendSet) window.__orgLegendSet = new Set();
                                window.__orgLegendSet.add(String(data.organization));
                                if (!window.__orgLegendASNMap) window.__orgLegendASNMap = new Map();
                                window.__orgLegendASNMap.set(String(data.organization), String(data.asn || ''));
                                if (typeof renderOrgLegendOverlay === 'function' && window.currentSvg) renderOrgLegendOverlay(window.currentSvg);
                            }
                        } catch (e) {}
                    })
                    .catch(err => {
                        console.error('ASN ошибка:', err);
                        text.value = 'Ошибка запроса ASN';
                    })
                    .finally(() => {
                        hideCidrContextMenu();
                    });
            } catch (err) {
                console.error('ASN подготовка ошибка:', err);
            }
        };

        // Клик вне меню закрывает его
        setTimeout(() => {
            document.addEventListener('click', hideCidrContextMenu, { once: true });
        }, 0);
    } catch (err) {
        console.error('Ошибка показа контекстного меню CIDR:', err);
    }
}

function hideCidrContextMenu() {
    const menu = document.getElementById('cidrContextMenu');
    if (menu) {
        menu.style.display = 'none';
    }
}

// ===== IP контекстное меню =====
let currentIpNode = null;

function showIpContextMenu(node, pageX, pageY) {
    try {
        let menu = document.getElementById('ipContextMenu');
        if (!menu) {
            menu = document.createElement('div');
            menu.id = 'ipContextMenu';
            menu.className = 'cidr-context-menu';
            menu.innerHTML = [
                '<div class="menu-item" data-action="upload_ports">Загрузить порты</div>',
                '<div class="menu-item" data-action="toggle_domains">Отобразить домены</div>'
            ].join('');
            document.body.appendChild(menu);
        }
        currentIpNode = node;
        menu.style.left = pageX + 'px';
        menu.style.top = pageY + 'px';
        menu.style.display = 'block';

        const uploadItem = menu.querySelector('[data-action="upload_ports"]');
        const toggleItem = menu.querySelector('[data-action="toggle_domains"]');

        uploadItem.onclick = function(e) {
            e.stopPropagation();
            showPortUploadModal(currentIpNode.id);
            hideIpContextMenu();
        };
        toggleItem.onclick = function(e) {
            e.stopPropagation();
            toggleDomainsForIp(currentIpNode.id);
            hideIpContextMenu();
        };

        setTimeout(() => { document.addEventListener('click', hideIpContextMenu, { once: true }); }, 0);
    } catch (err) { console.error('Ошибка показа контекстного меню IP:', err); }
}

function hideIpContextMenu() {
    const menu = document.getElementById('ipContextMenu');
    if (menu) menu.style.display = 'none';
}

function toggleDomainsForIp(ipId) {
    try {
        const all = attackSurfaceData.nodes || [];
        const domainNodes = all.filter(n => n.type === 'domain' && n.ip === ipId);
        if (!domainNodes.length) return;
        const visibleIds = new Set((window.__lastGraphNodes || []).map(n => n.id));
        const anyVisible = domainNodes.some(n => visibleIds.has(n.id));
        if (anyVisible) {
            // скрыть
            const keep = (window.__lastGraphNodes || []).filter(n => !(n.type === 'domain' && n.ip === ipId));
            const keepIds = new Set(keep.map(n => n.id));
            const keepLinks = (window.__lastGraphLinks || []).filter(l => {
                const sId = (l.source && typeof l.source === 'object') ? l.source.id : l.source;
                const tId = (l.target && typeof l.target === 'object') ? l.target.id : l.target;
                return keepIds.has(sId) && keepIds.has(tId);
            });
            window.__lastGraphNodes = keep;
            window.__lastGraphLinks = keepLinks;
            updateGraph();
        } else {
            // показать
            const currentIds = new Set((window.__lastGraphNodes || []).map(n => n.id));
            const newNodes = (window.__lastGraphNodes || []).concat(domainNodes.filter(n => !currentIds.has(n.id)));
            const linkPool = (attackSurfaceData.links || []).concat(attackSurfaceData.edges || []);
            const newLinks = (window.__lastGraphLinks || []).concat(linkPool.filter(l => {
                const sId = (l.source && typeof l.source === 'object') ? l.source.id : l.source;
                const tId = (l.target && typeof l.target === 'object') ? l.target.id : l.target;
                return newNodes.some(n => n.id === sId) && newNodes.some(n => n.id === tId);
            }));
            window.__lastGraphNodes = newNodes;
            window.__lastGraphLinks = newLinks;
            updateGraph();
        }
    } catch (e) { console.error('toggleDomainsForIp error', e); }
}

function getIpsForCidr(cidrId) {
    if (!attackSurfaceData) return [];
    const edges = attackSurfaceData.edges || [];
    const ips = edges
        .filter(e => e.label === 'contains' && e.from === cidrId)
        .map(e => e.to);
    return Array.from(new Set(ips));
}

function getDomainsForIps(ipList) {
    if (!attackSurfaceData || !Array.isArray(ipList)) return [];
    const nodes = attackSurfaceData.nodes || [];
    const domains = nodes
        .filter(n => n.type === 'domain' && n.ip && ipList.includes(n.ip))
        .map(n => n.id);
    return Array.from(new Set(domains));
}

function renderCidrResultsList(itemType, cidrId, items) {
    try {
        const card = document.getElementById('cidrResultsCard');
        const title = document.getElementById('cidrResultsTitle');
        const text = document.getElementById('cidrResultsText');

        title.textContent = `${itemType} для ${cidrId}`;
        if (!items || items.length === 0) {
            text.value = 'Список пуст';
        } else {
            text.value = items.join('\n');
        }

        card.style.display = 'block';
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } catch (err) {
        console.error('Ошибка отображения результатов CIDR:', err);
    }
}

function clearCidrResults() {
    const card = document.getElementById('cidrResultsCard');
    const text = document.getElementById('cidrResultsText');
    const title = document.getElementById('cidrResultsTitle');
    title.textContent = '';
    if (text) text.value = '';
    card.style.display = 'none';
}

async function deleteAttackSurfaceDomain(domainName) {
    try {
        if (!currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        if (!confirm(`Удалить домен ${domainName}?`)) return;
        const res = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
        const data = await res.json();
        if (!data.success) { alert('Не удалось загрузить список доменов'); return; }
        const match = (data.domains || []).find(x => String(x.domain) === String(domainName));
        if (!match) { alert('Домен не найден'); return; }
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains/${match.id}`, { method: 'DELETE' });
        const j = await r.json();
        if (j && j.success) {
            try {
                const ipStr = String(match.ip || '').trim();
                if (ipStr) {
                    const afterRes = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
                    const afterData = await afterRes.json();
                    if (afterData && afterData.success) {
                        const stillHas = (afterData.domains || []).some(d => String(d.ip || '') === ipStr);
                        if (!stillHas) {
                            const ipsRes = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses`);
                            const ipsData = await ipsRes.json();
                            if (ipsData && ipsData.success) {
                                const ipRec = (ipsData.ips || []).find(i => String(i.ip) === ipStr);
                                if (ipRec) {
                                    await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses/${ipRec.id}`, { method: 'DELETE' });
                                }
                            }
                        }
                    }
                }
            } catch (e) {}
            try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) { updateAttackSurfaceDisplay(); }
        } else {
            alert('Ошибка удаления: ' + (j && j.error ? j.error : '')); 
        }
    } catch (e) {
        alert('Ошибка удаления домена');
    }
}

// Показать модальное окно создания сайта
function showCreateSiteModal(domain, url) {
    document.getElementById('siteName').value = domain;
    document.getElementById('siteUrl').value = url.startsWith('http') ? url : `https://${url}`;
    document.getElementById('selectedDomain').value = domain;
    
    // Загрузка списка проектов
    fetch('/api/projects')
        .then(response => response.json())
        .then(data => {
            const select = document.getElementById('siteProject');
            select.innerHTML = '<option value="">Без проекта</option>';
            data.forEach(project => {
                select.innerHTML += `<option value="${project.id}">${project.name}</option>`;
            });
            
            // Автоматически выбрать проект текущего Attack Surface
            if (currentAttackSurfaceId) {
                fetch(`/api/attack-surfaces/${currentAttackSurfaceId}`)
                    .then(response => response.json())
                    .then(asData => {
                        if (asData.success && asData.attack_surface.project_id) {
                            select.value = asData.attack_surface.project_id;
                        }
                    })
                    .catch(error => console.error('Ошибка получения проекта Attack Surface:', error));
            }
        });
    
    new bootstrap.Modal(document.getElementById('createSiteModal')).show();
}

// Создать сайт из домена
function createSiteFromDomain() {
    const name = document.getElementById('siteName').value;
    const url = document.getElementById('siteUrl').value;
    const projectId = document.getElementById('siteProject').value;
    
    if (!name || !url) {
        alert('Пожалуйста, заполните все обязательные поля');
        return;
    }
    
    const data = {
        name: name,
        url: url,
        status: 'Не начат'
    };
    
    if (projectId) {
        data.project_id = parseInt(projectId);
    }
    
    fetch('/api/websites', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('Сайт успешно создан!');
            bootstrap.Modal.getInstance(document.getElementById('createSiteModal')).hide();
            try {
                const w = data.website || { id: data.website_id, url };
                let cache = window.__websitesCache || [];
                const idx = cache.findIndex(x => Number(x.id) === Number(w.id));
                if (idx >= 0) cache[idx] = { ...cache[idx], url: w.url, status: w.status || 'Не начат' }; else cache.push({ id: Number(w.id), url: w.url, status: w.status || 'Не начат' });
                window.__websitesCache = cache;
            } catch (e) {}
            try { markDomainRowHasCard(document.getElementById('selectedDomain').value, data.website || { id: data.website_id, status: 'Не начат' }); } catch (e) {}
            try { localStorage.setItem('__websiteUpdated', JSON.stringify({ id: Number((data.website && data.website.id) || data.website_id), status: (data.website && data.website.status) || 'Не начат', ts: Date.now() })); } catch (e) {}
        } else {
            alert('Ошибка создания сайта: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при создании сайта');
    });
}

// Показать порты домена
function showDomainPorts(domainName) { }

// Функции управления графом
function resetGraphZoom() {
    if (currentSvg && currentZoom) {
        currentSvg.transition().duration(750).call(
            currentZoom.transform,
            d3.zoomIdentity
        );
    }
}

// Показать модальное окно быстрой загрузки портов для IP-адреса
function showPortUploadModal(ipAddress) {
    document.getElementById('selectedIpAddress').textContent = ipAddress;
    document.getElementById('targetIpForPorts').value = ipAddress;
    
    // Сбросить форму
    document.getElementById('quickPortUploadForm').reset();
    document.getElementById('quickPortsPreview').style.display = 'none';
    document.getElementById('quickUploadPortsBtn').disabled = true;
    
    new bootstrap.Modal(document.getElementById('quickPortUploadModal')).show();
}

// Загрузить порты для выбранного IP-адреса
function uploadQuickPorts() {
    const ipAddress = document.getElementById('targetIpForPorts').value;
    const fileInput = document.getElementById('quickNmapXmlFile');
    
    if (!ipAddress) {
        alert('IP-адрес не выбран');
        return;
    }
    
    if (!fileInput.files[0]) {
        alert('Пожалуйста, выберите XML файл');
        return;
    }
    
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    
    // Проверяем, что порты уже распарсены
    if (!window.quickParsedPorts || window.quickParsedPorts.length === 0) {
        alert('Сначала выберите и обработайте XML файл');
        return;
    }
    
    fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-nmap-ports`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            target_ip: ipAddress,
            ports: window.quickParsedPorts || []
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert(`Успешно загружено портов: ${data.total_added}\nПропущено дубликатов: ${data.total_skipped}\nОбновлено доменов: ${data.updated_domains.length}`);
            bootstrap.Modal.getInstance(document.getElementById('quickPortUploadModal')).hide();
            // Полностью перезагрузить граф и таблицу
            if (typeof loadAttackSurfaceGraph === 'function') {
                loadAttackSurfaceGraph(currentAttackSurfaceId);
            } else if (typeof updateAttackSurfaceDisplay === 'function') {
            try {
                // При загрузке нового графа сбрасываем сохраненное состояние
                window.__lastGraphNodes = null;
                window.__lastGraphLinks = null;
            } catch (e) {}
            updateAttackSurfaceDisplay();
            }
        } else {
            alert('Ошибка загрузки портов: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при загрузке портов');
    });
}

// Показать модальное окно загрузки портов
function showUploadNmapPortsModal() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    
    // Заполнить список IP-адресов
    const ipSelect = document.getElementById('targetIpSelect');
    ipSelect.innerHTML = '<option value="">Выберите IP-адрес для загрузки портов</option>';
    
    // Собрать уникальные IP-адреса из графа и доменов
    const uniqueIps = new Set();
    // Из узлов графа (узлы типа IP)
    if (attackSurfaceData.nodes && attackSurfaceData.nodes.length) {
        attackSurfaceData.nodes.forEach(node => {
            if (node.type === 'ip' && node.id) {
                uniqueIps.add(node.id);
            }
        });
    }
    // Из доменной таблицы (если IP разрешен)
    if (attackSurfaceData.domains && attackSurfaceData.domains.length) {
        attackSurfaceData.domains.forEach(domain => {
            if (domain.ip && domain.ip !== 'Не разрешен') {
                uniqueIps.add(domain.ip);
            }
        });
    }
    
    uniqueIps.forEach(ip => {
        const option = document.createElement('option');
        option.value = ip;
        option.textContent = ip;
        ipSelect.appendChild(option);
    });
    
    // Сбросить форму
    document.getElementById('uploadNmapPortsForm').reset();
    document.getElementById('portsPreview').style.display = 'none';
    document.getElementById('uploadPortsBtn').disabled = true;
    
    new bootstrap.Modal(document.getElementById('uploadNmapPortsModal')).show();
}

function showProjectNmapUploadModal() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    document.getElementById('projectNmapUploadForm').reset();
    document.getElementById('projectPortsPreview').style.display = 'none';
    document.getElementById('projectUploadPortsBtn').disabled = true;
    new bootstrap.Modal(document.getElementById('projectNmapUploadModal')).show();
}

function showProjectUdpUploadModal() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    document.getElementById('projectUdpUploadForm').reset();
    document.getElementById('projectUdpPortsPreview').style.display = 'none';
    document.getElementById('projectUploadUdpPortsBtn').disabled = true;
    new bootstrap.Modal(document.getElementById('projectUdpUploadModal')).show();
}

// Обработчик изменения файла XML
document.addEventListener('DOMContentLoaded', function() {
    const fileInput = document.getElementById('nmapXmlFile');
    const ipSelect = document.getElementById('targetIpSelect');
    const quickFileInput = document.getElementById('quickNmapXmlFile');
    const tcpFileInput = document.getElementById('tcpXmlFile');
    const projectFileInput = document.getElementById('projectXmlFile');
    const projectUdpFileInput = document.getElementById('projectUdpTxtFile');
    
    if (fileInput) {
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'text/xml') {
                parseNmapXml(file);
            }
        });
    }
    
    if (quickFileInput) {
        quickFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'text/xml') {
                parseQuickNmapXml(file);
            }
        });
    }
    
    if (ipSelect) {
        ipSelect.addEventListener('change', function() {
            updateUploadButton();
        });
    }

    if (tcpFileInput) {
        tcpFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            parseTcpNmapXml(file);
        });
    }
    if (projectFileInput) {
        projectFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            parseProjectNmapXml(file);
        });
    }
    if (projectUdpFileInput) {
        projectUdpFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            parseProjectUdpxTxt(file);
        });
    }
});

// Парсинг XML файла Nmap
function parseNmapXml(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
            
            // Проверить на ошибки парсинга
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                throw new Error('Ошибка парсинга XML файла');
            }
            
            // Извлечь порты из XML
            const ports = [];
            const hosts = xmlDoc.querySelectorAll('host');
            
            hosts.forEach(host => {
                const portElements = host.querySelectorAll('port');
                portElements.forEach(portEl => {
                    const portId = portEl.getAttribute('portid');
                    const protocol = portEl.getAttribute('protocol');
                    const state = portEl.querySelector('state')?.getAttribute('state');
                    const service = portEl.querySelector('service')?.getAttribute('name') || '';
                    
                    if (state === 'open' && portId) {
                        ports.push({
                            port: parseInt(portId),
                            protocol: protocol || 'tcp',
                            service: service
                        });
                    }
                });
            });
            
            displayPortsPreview(ports);
            
        } catch (error) {
            console.error('Ошибка парсинга XML:', error);
            alert('Ошибка при чтении XML файла: ' + error.message);
        }
    };
    
    reader.readAsText(file);
}

function parseProjectNmapXml(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) throw new Error('Ошибка парсинга XML файла');
            const entries = [];
            const hosts = xmlDoc.querySelectorAll('host');
            hosts.forEach(host => {
                const addrEl = host.querySelector('address[addrtype="ipv4"]');
                const address = addrEl ? addrEl.getAttribute('addr') : '';
                const portEls = host.querySelectorAll('port');
                portEls.forEach(portEl => {
                    const portId = portEl.getAttribute('portid');
                    const protocol = portEl.getAttribute('protocol') || 'tcp';
                    const state = portEl.querySelector('state')?.getAttribute('state');
                    const service = portEl.querySelector('service')?.getAttribute('name') || '';
                    if (state === 'open' && portId && address) {
                        entries.push({ address, port: parseInt(portId, 10), protocol, service });
                    }
                });
            });
            window.projectParsedEntries = entries;
            const preview = document.getElementById('projectPortsPreviewContent');
            const previewWrap = document.getElementById('projectPortsPreview');
            if (!entries.length) {
                preview.innerHTML = '<div class="text-muted">Порты не найдены</div>';
            } else {
                const byIp = {};
                entries.forEach(e => { if (!byIp[e.address]) byIp[e.address] = []; byIp[e.address].push(e); });
                let html = '';
                Object.entries(byIp).forEach(([ip, list]) => {
                    html += `<div class="mb-2"><code>${ip}</code>: ` + list.map(item => `${item.port}/${item.protocol}${item.service ? ' (' + item.service + ')' : ''}`).join(', ') + '</div>';
                });
                preview.innerHTML = html;
            }
            previewWrap.style.display = 'block';
            document.getElementById('projectUploadPortsBtn').disabled = entries.length === 0;
        } catch (err) {
            console.error('Ошибка парсинга XML:', err);
            alert('Ошибка при чтении XML файла: ' + err.message);
        }
    };
    reader.readAsText(file);
}

function uploadProjectPorts() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    const entries = window.projectParsedEntries || [];
    if (!entries.length) {
        alert('Сначала выберите и обработайте XML файл');
        return;
    }
    const byIp = {};
    entries.forEach(e => {
        const ip = (e.address || '').trim();
        if (!ip) return;
        if (!byIp[ip]) byIp[ip] = [];
        byIp[ip].push({ port: e.port, protocol: e.protocol || 'tcp', service: e.service, status: 'open' });
    });
    const promises = [];
    let totalAdded = 0;
    let totalSkipped = 0;
    let updatedDomainsCount = 0;
    let matchedIps = 0;
    const ipsInGraph = new Set((attackSurfaceData.nodes || []).filter(n => n.type === 'ip').map(n => n.id));
    Object.entries(byIp).forEach(([ip, ports]) => {
        if (ipsInGraph.size === 0 || ipsInGraph.has(ip)) {
            matchedIps += 1;
            promises.push(
                fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-nmap-ports`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target_ip: ip, ports })
                })
                .then(r => r.json())
                .then(data => {
                    if (data && data.success) {
                        totalAdded += data.total_added || 0;
                        totalSkipped += data.total_skipped || 0;
                        updatedDomainsCount += (data.updated_domains ? data.updated_domains.length : 0);
                    }
                })
            );
        }
    });
    Promise.all(promises)
        .then(() => {
            alert(`Проектная загрузка завершена\nУспешно: ${totalAdded}\nДубликаты: ${totalSkipped}\nОбновлено доменов: ${updatedDomainsCount}\nIP затронуто: ${matchedIps}`);
            bootstrap.Modal.getInstance(document.getElementById('projectNmapUploadModal')).hide();
            if (typeof loadAttackSurfaceGraph === 'function') {
                loadAttackSurfaceGraph(currentAttackSurfaceId);
            } else if (typeof updateAttackSurfaceDisplay === 'function') {
                updateAttackSurfaceDisplay();
            }
        })
        .catch(err => {
            console.error('Ошибка проектной загрузки портов:', err);
            alert('Ошибка при загрузке портов');
        });
}

function parseProjectUdpxTxt(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const lines = e.target.result.split(/\r?\n/).filter(l => l.trim().length > 0);
            const entries = [];
            for (const line of lines) {
                try {
                    const obj = JSON.parse(line);
                    const address = obj.address || obj.ip || '';
                    const port = obj.port || obj.number;
                    const service = obj.service || '';
                    if (!port || !address) continue;
                    entries.push({ address, port: parseInt(port, 10), protocol: 'udp', service });
                } catch (err) {}
            }
            window.projectParsedUdpEntries = entries;
            const preview = document.getElementById('projectUdpPortsPreviewContent');
            const wrap = document.getElementById('projectUdpPortsPreview');
            if (!entries.length) {
                preview.innerHTML = '<div class="text-muted">UDP порты не найдены</div>';
            } else {
                const byIp = {};
                entries.forEach(e => { if (!byIp[e.address]) byIp[e.address] = []; byIp[e.address].push(e); });
                let html = '';
                Object.entries(byIp).forEach(([ip, list]) => {
                    html += `<div class="mb-2"><code>${ip}</code>: ` + list.map(item => `${item.port}/udp${item.service ? ' (' + item.service + ')' : ''}`).join(', ') + '</div>';
                });
                preview.innerHTML = html;
            }
            wrap.style.display = 'block';
            document.getElementById('projectUploadUdpPortsBtn').disabled = entries.length === 0;
        } catch (err) {
            alert('Ошибка при чтении udpx.txt файла');
        }
    };
    reader.readAsText(file);
}

function uploadProjectUdpPorts() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    const entries = window.projectParsedUdpEntries || [];
    if (!entries.length) {
        alert('Сначала выберите и обработайте udpx.txt');
        return;
    }
    const byIp = {};
    entries.forEach(e => {
        const ip = (e.address || '').trim();
        if (!ip) return;
        if (!byIp[ip]) byIp[ip] = [];
        byIp[ip].push({ port: e.port, protocol: 'udp', service: e.service, status: 'open' });
    });
    const promises = [];
    let totalAdded = 0;
    let totalSkipped = 0;
    let updatedDomainsCount = 0;
    let matchedIps = 0;
    const ipsInGraph = new Set((attackSurfaceData.nodes || []).filter(n => n.type === 'ip').map(n => n.id));
    Object.entries(byIp).forEach(([ip, ports]) => {
        if (ipsInGraph.size === 0 || ipsInGraph.has(ip)) {
            matchedIps += 1;
            promises.push(
                fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-udp-ports`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target_ip: ip, ports })
                })
                .then(r => r.json())
                .then(data => {
                    if (data && data.success) {
                        totalAdded += data.total_added || 0;
                        totalSkipped += data.total_skipped || 0;
                        updatedDomainsCount += (data.updated_domains ? data.updated_domains.length : 0);
                    }
                })
            );
        }
    });
    const btn = document.getElementById('projectUploadUdpPortsBtn');
    btn.disabled = true;
    btn.textContent = 'Загружаю...';
    Promise.all(promises)
        .then(() => {
            alert(`Проектная UDP загрузка завершена\nУспешно: ${totalAdded}\nДубликаты: ${totalSkipped}\nОбновлено доменов: ${updatedDomainsCount}\nIP затронуто: ${matchedIps}`);
            bootstrap.Modal.getInstance(document.getElementById('projectUdpUploadModal')).hide();
            if (typeof loadAttackSurfaceGraph === 'function') {
                loadAttackSurfaceGraph(currentAttackSurfaceId);
            } else if (typeof updateAttackSurfaceDisplay === 'function') {
                updateAttackSurfaceDisplay();
            }
        })
        .catch(() => {
            alert('Ошибка при загрузке UDP портов');
        })
        .finally(() => {
            btn.disabled = false;
            btn.textContent = 'Загрузить UDP';
        });
}

// ===== UDP загрузка из udpx.txt =====
document.addEventListener('DOMContentLoaded', function() {
    const udpFileInput = document.getElementById('udpTxtFile');
    if (udpFileInput) {
        udpFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            parseUdpxTxt(file);
        });
    }
});

function populateUdpIpSelect(ipList) {
    // Удалено: наполнение селекта IP. Теперь селекта нет.
}

function parseUdpxTxt(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const lines = e.target.result.split(/\r?\n/).filter(l => l.trim().length > 0);
            const entries = [];
            for (const line of lines) {
                try {
                    const obj = JSON.parse(line);
                    const address = obj.address || obj.ip || '';
                    const port = obj.port || obj.number;
                    const service = obj.service || '';
                    if (!port) continue;
                    entries.push({ address, port: parseInt(port, 10), protocol: 'udp', service });
                } catch (err) {
                    // игнорируем строки, не являющиеся корректным JSON
                }
            }
            window.parsedUdpEntries = entries;
            displayUdpPortsPreview(entries);
        } catch (err) {
            console.error('Ошибка парсинга udpx.txt:', err);
            alert('Ошибка при чтении udpx.txt файла');
        }
    };
    reader.readAsText(file);
}

function displayUdpPortsPreview(entries) {
    const previewDiv = document.getElementById('udpPortsPreviewContent');
    const previewContainer = document.getElementById('udpPortsPreview');

    if (!entries || entries.length === 0) {
        previewDiv.innerHTML = '<div class="text-muted">UDP порты не найдены</div>';
    } else {
        // Сгруппируем по портам для компактного отображения
        let html = '<div class="row">';
        entries.forEach((item, index) => {
            if (index % 3 === 0 && index > 0) {
                html += '</div><div class="row">';
            }
            html += `
                <div class="col-4 mb-2">
                    <span class="badge bg-warning" style="color: #000 !important;">${item.port}/udp</span>
                    ${item.service ? `<small class="text-muted ms-1">${item.service}</small>` : ''}
                </div>
            `;
        });
        html += '</div>';
        previewDiv.innerHTML = html;
    }

    previewContainer.style.display = 'block';
    updateUdpUploadButton();
}

function updateUdpUploadButton() {
    // Кнопка активируется, если есть распарсенные записи с адресами или без (будем пытаться сопоставить)
    const uploadBtn = document.getElementById('uploadUdpPortsBtn');
    const hasEntries = window.parsedUdpEntries && window.parsedUdpEntries.length > 0;
    if (uploadBtn) uploadBtn.disabled = !hasEntries;
}

function uploadUdpPorts() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    if (!window.parsedUdpEntries || window.parsedUdpEntries.length === 0) {
        alert('Сначала выберите и обработайте udpx.txt');
        return;
    }

    const uploadBtn = document.getElementById('uploadUdpPortsBtn');
    uploadBtn.disabled = true;
    uploadBtn.textContent = 'Загружаю...';
    try {
        if (!currentCidrNode || !currentCidrNode.id) {
            alert('CIDR не выбран');
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Загрузить UDP порты';
            return;
        }
        const byIp = {};
        for (const e of window.parsedUdpEntries) {
            const ip = (e.address || '').trim();
            if (!ip) continue;
            if (!byIp[ip]) byIp[ip] = [];
            byIp[ip].push({ port: e.port, service: e.service, protocol: 'udp', status: 'open' });
        }
        const promises = [];
        let totalAdded = 0;
        let totalSkipped = 0;
        let updatedDomainsCount = 0;
        let matchedIps = 0;
        for (const [ip, ports] of Object.entries(byIp)) {
            if (isIpInCidr(ip, currentCidrNode.id)) {
                matchedIps += 1;
                promises.push(
                    fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-udp-ports`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ target_ip: ip, ports })
                    })
                    .then(r => r.json())
                    .then(data => {
                        if (data && data.success) {
                            totalAdded += data.total_added || 0;
                            totalSkipped += data.total_skipped || 0;
                            updatedDomainsCount += (data.updated_domains ? data.updated_domains.length : 0);
                        }
                    })
                );
            }
        }
        Promise.all(promises)
            .then(() => {
                alert(`Успешно загружено UDP портов: ${totalAdded}\nПропущено дубликатов: ${totalSkipped}\nОбновлено доменов: ${updatedDomainsCount}\nСопоставлено IP: ${matchedIps}`);
                bootstrap.Modal.getInstance(document.getElementById('uploadUdpPortsModal')).hide();
                if (typeof loadAttackSurfaceGraph === 'function') {
                    loadAttackSurfaceGraph(currentAttackSurfaceId);
                } else if (typeof updateAttackSurfaceDisplay === 'function') {
                    updateAttackSurfaceDisplay();
                }
            })
            .catch(err => {
                console.error('Ошибка:', err);
                alert('Произошла ошибка при загрузке UDP портов');
            })
            .finally(() => {
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Загрузить UDP порты';
            });
    } catch (err) {
        console.error('Ошибка подготовки загрузки UDP:', err);
        alert('Ошибка подготовки данных для загрузки UDP портов');
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Загрузить UDP порты';
    }
}

// Парсинг XML файла Nmap для быстрой загрузки
function parseQuickNmapXml(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
            
            // Проверить на ошибки парсинга
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                throw new Error('Ошибка парсинга XML файла');
            }
            
            // Извлечь порты из XML
            const ports = [];
            const hosts = xmlDoc.querySelectorAll('host');
            
            hosts.forEach(host => {
                const portElements = host.querySelectorAll('port');
                portElements.forEach(portEl => {
                    const portId = portEl.getAttribute('portid');
                    const protocol = portEl.getAttribute('protocol');
                    const state = portEl.querySelector('state')?.getAttribute('state');
                    const service = portEl.querySelector('service')?.getAttribute('name') || '';
                    
                    if (state === 'open' && portId) {
                        ports.push({
                            port: parseInt(portId),
                            protocol: protocol || 'tcp',
                            service: service
                        });
                    }
                });
            });
            
            displayQuickPortsPreview(ports);
            
        } catch (error) {
            console.error('Ошибка парсинга XML:', error);
            alert('Ошибка при чтении XML файла: ' + error.message);
        }
    };
    
    reader.readAsText(file);
}

// Отображение предварительного просмотра портов для быстрой загрузки
function displayQuickPortsPreview(ports) {
    const previewDiv = document.getElementById('quickPortsPreviewContent');
    const previewContainer = document.getElementById('quickPortsPreview');
    
    if (ports.length === 0) {
        previewDiv.innerHTML = '<div class="text-muted">Открытые порты не найдены</div>';
    } else {
        let html = '<div class="row">';
        ports.forEach((port, index) => {
            if (index % 3 === 0 && index > 0) {
                html += '</div><div class="row">';
            }
            html += `
                <div class="col-4 mb-2">
                    <span class="badge bg-info" style="color: #000 !important;">${port.port}/${port.protocol}</span>
                    ${port.service ? `<small class="text-muted ms-1">${port.service}</small>` : ''}
                </div>
            `;
        });
        html += '</div>';
        previewDiv.innerHTML = html;
    }
    
    previewContainer.style.display = 'block';
    window.quickParsedPorts = ports; // Сохранить для загрузки
    document.getElementById('quickUploadPortsBtn').disabled = false;
}

// Отображение предварительного просмотра портов
function displayPortsPreview(ports) {
    const previewDiv = document.getElementById('portsPreviewContent');
    const previewContainer = document.getElementById('portsPreview');
    
    if (ports.length === 0) {
        previewDiv.innerHTML = '<div class="text-muted">Открытые порты не найдены</div>';
    } else {
        let html = '<div class="row">';
        ports.forEach((port, index) => {
            if (index % 3 === 0 && index > 0) {
                html += '</div><div class="row">';
            }
            html += `
                <div class="col-4 mb-2">
                    <span class="badge bg-info" style="color: #000 !important;">${port.port}/${port.protocol}</span>
                    ${port.service ? `<small class="text-muted ms-1">${port.service}</small>` : ''}
                </div>
            `;
        });
        html += '</div>';
        previewDiv.innerHTML = html;
    }
    
    previewContainer.style.display = 'block';
    window.parsedPorts = ports; // Сохранить для загрузки
    updateUploadButton();
}

// Обновление состояния кнопки загрузки
function updateUploadButton() {
    const ipSelect = document.getElementById('targetIpSelect');
    const uploadBtn = document.getElementById('uploadPortsBtn');
    
    const hasIp = ipSelect.value !== '';
    const hasPorts = window.parsedPorts && window.parsedPorts.length > 0;
    
    uploadBtn.disabled = !(hasIp && hasPorts);
}

// Загрузка портов на сервер
function uploadNmapPorts() {
    const targetIp = document.getElementById('targetIpSelect').value;
    
    if (!targetIp || !window.parsedPorts || window.parsedPorts.length === 0) {
        alert('Выберите IP-адрес и загрузите корректный XML файл');
        return;
    }
    
    const uploadBtn = document.getElementById('uploadPortsBtn');
    uploadBtn.disabled = true;
    uploadBtn.textContent = 'Загружаю...';
    
    fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-nmap-ports`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            target_ip: targetIp,
            ports: window.parsedPorts
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert(`Успешно загружено портов: ${data.total_added}\nПропущено дубликатов: ${data.total_skipped}\nОбновлено доменов: ${data.updated_domains.length}`);
            bootstrap.Modal.getInstance(document.getElementById('uploadNmapPortsModal')).hide();
            // Полностью перезагрузить граф и таблицу
            if (typeof loadAttackSurfaceGraph === 'function') {
                loadAttackSurfaceGraph(currentAttackSurfaceId);
            } else if (typeof updateAttackSurfaceDisplay === 'function') {
                updateAttackSurfaceDisplay();
            }
        } else {
            alert('Ошибка загрузки портов: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Произошла ошибка при загрузке портов');
    })
    .finally(() => {
        uploadBtn.disabled = false;
        uploadBtn.textContent = 'Загрузить порты';
    });
}

function centerGraph() {
    if (!window.d3) { loadD3AndThen(centerGraph); return; }
    if (currentSvg && currentZoom) {
        const container = document.getElementById('attackSurfaceGraph');
        const width = container.clientWidth;
        const height = 600;
        
        currentSvg.transition().duration(750).call(
            currentZoom.transform,
            d3.zoomIdentity.translate(width / 2, height / 2).scale(1)
        );
    }
}

function zoomToFitCurrentGraph(paddingRatio) {
    try {
        if (!window.d3) { loadD3AndThen(function(){ zoomToFitCurrentGraph(paddingRatio); }); return; }
        if (!window.currentSvg || !window.currentZoom) return;
        const container = document.getElementById('attackSurfaceGraph');
        const width = container.clientWidth;
        const height = 600;
        const g = window.currentSvg.select('g');
        if (!g || g.empty()) return;
        let bbox;
        try { bbox = g.node().getBBox(); } catch (e) { return; }
        if (!bbox || !isFinite(bbox.width) || !isFinite(bbox.height)) return;
        const pad = (typeof paddingRatio === 'number' && paddingRatio > 0 && paddingRatio < 1.5) ? paddingRatio : 0.9;
        const scaleX = width / (bbox.width || 1);
        const scaleY = height / (bbox.height || 1);
        let k = Math.min(scaleX, scaleY) * pad;
        if (!isFinite(k) || k <= 0) k = 1;
        k = Math.max(0.1, Math.min(10, k));
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;
        const tx = width / 2 - cx * k;
        const ty = height / 2 - cy * k;
        window.currentSvg.transition().duration(600).call(
            window.currentZoom.transform,
            d3.zoomIdentity.translate(tx, ty).scale(k)
        );
    } catch (e) {}
}

function showGraphHelp() {
    const helpText = `
Управление графом Attack Surface:

🖱️ Перемещение:
• Зажмите левую кнопку мыши и перетащите для панорамирования
• Перетаскивайте отдельные узлы для изменения их позиции

🔍 Масштабирование:
• Используйте колесо мыши для увеличения/уменьшения
• Диапазон масштаба: от 10% до 1000%

🎯 Кнопки управления:
• 🔍 Сбросить масштаб - возврат к исходному размеру
• 🎯 Центрировать граф - размещение графа по центру

💡 Взаимодействие:
• Кликните по домену для создания карточки сайта
• Цвета узлов: синий = домен, зеленый = IP, красный = CIDR
    `;
    
    alert(helpText);
}

// ===== Легенда портов проекта с фильтром по CIDR =====
function loadPortsLegend(selectedCidrs = []) {
    if (!window.d3) { loadD3AndThen(function(){ loadPortsLegend(selectedCidrs); }); return; }
    try {
        window.__portsLegendSelectedCidrs = selectedCidrs || [];
        const params = new URLSearchParams();
        (selectedCidrs || []).forEach(c => params.append('cidr', c));
        fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ports-summary?` + params.toString())
            .then(r => r && r.json())
            .then(data => {
                if (!data || !data.success) return;
                window.__portsLegendData = data;
                try {
                    const webPorts = Array.from(new Set((data.web_ports || []).map(Number).filter(Boolean)));
                    window.__webPorts = webPorts;
                } catch (e) {}
                document.getElementById('portsLegendContainer').style.display = 'block';
                if (typeof renderPortsLegendOverlay === 'function') {
                    const container = document.getElementById('attackSurfaceGraph');
                    const svg = d3.select(container).select('svg');
                    renderPortsLegendOverlay(svg);
                }
            })
            .catch(err => console.error('Ошибка загрузки легенды портов:', err));
    } catch (err) {
        console.error('Ошибка легенды портов:', err);
    }
}

function applyPortsLegendFilter() {
    const select = document.getElementById('portsLegendCidrSelect');
    const selectedCidrs = Array.from(select.selectedOptions).map(opt => opt.value);
    loadPortsLegend(selectedCidrs);
}

function resetPortsLegendFilter() {
    loadPortsLegend([]);
}

function renderPortsLegendOverlay(svg) {
    try {
        if (!window.d3) { loadD3AndThen(function(){ renderPortsLegendOverlay(svg); }); return; }
        const data = window.__portsLegendData || { ports: [], cidrs: [] };
        if (!svg || svg.empty()) return;
        svg.selectAll('g.ports-legend').remove();
        const width = parseFloat(svg.attr('width')) || 800;
        const padding = 12;
        const legendWidth = 340;
        const x = width - legendWidth - padding;
        const y = padding;
        const HEADER_EXTRA = 24;
        const PORTS_PER_PAGE = 12;
        const state = window.__portsLegendState || { portPage: 0, cidrPage: 0 };
        const portsAll = (data.ports || []).filter(p => (p.total || p.count || 0) > 0);
        const totalPortPages = Math.max(1, Math.ceil(portsAll.length / PORTS_PER_PAGE));
        const portPage = Math.min(state.portPage || 0, totalPortPages - 1);
        const cidrPage = state.cidrPage || 0;
        const ports = portsAll.slice(portPage * PORTS_PER_PAGE, portPage * PORTS_PER_PAGE + PORTS_PER_PAGE);
        const portsBlockH = ports.length * 18;
        const legendHeight = 48 + HEADER_EXTRA + portsBlockH + 12 + 10 + 16;
        const defs = svg.select('defs').empty() ? svg.append('defs') : svg.select('defs');
        const shadow = defs.select('#legendShadow').empty() ? defs.append('filter').attr('id','legendShadow').attr('x','-50%').attr('y','-50%').attr('width','200%').attr('height','200%') : defs.select('#legendShadow');
        if (shadow.select('feDropShadow').empty()) shadow.append('feDropShadow').attr('dx',0).attr('dy',2).attr('stdDeviation',2).attr('flood-color','#000').attr('flood-opacity',0.4);
        const legend = svg.append('g').attr('class', 'ports-legend');
        legend.append('rect')
            .attr('x', x)
            .attr('y', y)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('width', legendWidth)
            .attr('height', legendHeight)
            .attr('fill', '#212529')
            .attr('stroke', '#444')
            .attr('stroke-width', 1)
            .attr('filter', 'url(#legendShadow)')
            .attr('opacity', 0.95);
        legend.append('rect')
            .attr('x', x)
            .attr('y', y)
            .attr('width', 6)
            .attr('height', legendHeight)
            .attr('fill', '#0d6efd');
        legend.append('text')
            .text('Порты')
            .attr('x', x + 18)
            .attr('y', y + 22)
            .attr('fill', '#f8f9fa')
            .attr('font-size', '13px')
            .attr('font-weight', 'bold');
        // Кнопка чекера httpx
        const checkerBtn = legend.append('g').attr('class','ports-checker-btn');
        checkerBtn.append('rect')
            .attr('x', x + 18)
            .attr('y', y + 34)
            .attr('rx', 6)
            .attr('ry', 6)
            .attr('width', 112)
            .attr('height', 22)
            .attr('fill', '#0d6efd')
            .attr('stroke', '#0b5ed7')
            .style('cursor','pointer')
            .on('click', startHttpxChecker);
        checkerBtn.append('text')
            .text('Проверить веб')
            .attr('x', x + 74)
            .attr('y', y + 49)
            .attr('fill', '#fff')
            .attr('font-size', '12px')
            .attr('text-anchor','middle')
            .style('cursor','pointer')
            .on('click', startHttpxChecker);
        legend.append('line')
            .attr('x1', x + 18)
            .attr('y1', y + 28)
            .attr('x2', x + legendWidth - 18)
            .attr('y2', y + 28)
            .attr('stroke', '#444');
        const portsNavGroup = legend.append('g');
        portsNavGroup.append('text')
            .text('‹')
            .attr('x', x + legendWidth - 72)
            .attr('y', y + 22)
            .attr('fill', portPage > 0 ? '#0d6efd' : '#6c757d')
            .attr('font-size', '16px')
            .style('cursor', portPage > 0 ? 'pointer' : 'default')
            .on('click', () => {
                if (portPage > 0) {
                    window.__portsLegendState = { portPage: portPage - 1, cidrPage };
                    renderPortsLegendOverlay(svg);
                }
            });
        portsNavGroup.append('text')
            .text(`${portPage + 1}/${totalPortPages}`)
            .attr('x', x + legendWidth - 56)
            .attr('y', y + 22)
            .attr('fill', '#adb5bd')
            .attr('font-size', '12px');
        portsNavGroup.append('text')
            .text('›')
            .attr('x', x + legendWidth - 28)
            .attr('y', y + 22)
            .attr('fill', portPage < totalPortPages - 1 ? '#0d6efd' : '#6c757d')
            .attr('font-size', '16px')
            .style('cursor', portPage < totalPortPages - 1 ? 'pointer' : 'default')
            .on('click', () => {
                if (portPage < totalPortPages - 1) {
                    window.__portsLegendState = { portPage: portPage + 1, cidrPage };
                    renderPortsLegendOverlay(svg);
                }
            });
        const selectedPortsSet = new Set(window.__portsLegendSelectedPorts || []);
        const togglePort = (port) => {
            const s = new Set(window.__portsLegendSelectedPorts || []);
            if (s.has(port)) s.delete(port); else s.add(port);
            window.__portsLegendSelectedPorts = Array.from(s);
            updateAttackSurfaceTable();
            renderPortsLegendOverlay(svg);
        };
        ports.forEach((item, idx) => {
            const isSelected = selectedPortsSet.has(item.port);
            const rowY = y + 48 + HEADER_EXTRA + idx * 18;
            const isWeb = (() => { try { const s = new Set(window.__webPorts || []); return s.has(Number(item.port)); } catch (e) { return false; } })();
            legend.append('rect')
                .attr('x', x + 12)
                .attr('y', rowY - 12)
                .attr('rx', 6)
                .attr('ry', 6)
                .attr('width', legendWidth - 24)
                .attr('height', 20)
                .attr('fill', isSelected ? '#0d6efd' : (isWeb ? '#263a33' : '#343a40'))
                .attr('stroke', isSelected ? '#0b5ed7' : (isWeb ? '#198754' : '#495057'))
                .style('cursor', 'pointer')
                .on('click', () => togglePort(item.port));
            const label = legend.append('text')
                .text(() => {
                    const tcp = item.counts ? (item.counts.tcp || 0) : 0;
                    const udp = item.counts ? (item.counts.udp || 0) : 0;
                    const total = item.total != null ? item.total : (item.count != null ? item.count : (tcp + udp));
                    let protoLabel = '';
                    if (tcp && udp) protoLabel = 'tcp+udp';
                    else if (udp) protoLabel = 'udp';
                    else protoLabel = 'tcp';
                    try {
                        const webPorts = new Set(window.__webPorts || []);
                        const isWeb = webPorts.has(Number(item.port));
                        return isWeb ? `${String(item.port)} (${protoLabel}) web` : `${String(item.port)} (${protoLabel})`;
                    } catch (e) {
                        return `${String(item.port)} (${protoLabel})`;
                    }
                })
                .attr('x', x + 18)
                .attr('y', rowY)
                .attr('fill', isSelected ? '#ffffff' : (isWeb ? '#20c997' : '#e0e0e0'))
                .attr('font-size', '12px')
                .attr('font-family', 'monospace')
                .style('cursor', 'pointer')
                .on('click', () => togglePort(item.port));
            if (isWeb) {
                legend.append('text')
                    .text('web')
                    .attr('x', x + legendWidth - 100)
                    .attr('y', rowY)
                    .attr('fill', '#20c997')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold');
            }
            legend.append('text')
                .text(() => {
                    const tcp = item.counts ? (item.counts.tcp || 0) : 0;
                    const udp = item.counts ? (item.counts.udp || 0) : 0;
                    const total = item.total != null ? item.total : (item.count != null ? item.count : (tcp + udp));
                    return String(total);
                })
                .attr('x', x + legendWidth - 18)
                .attr('y', rowY)
                .attr('fill', isSelected ? '#dfe6f5' : (isWeb ? '#9be7d6' : '#adb5bd'))
                .attr('font-size', '12px')
                .attr('font-family', 'monospace')
                .attr('text-anchor', 'end')
                .style('cursor', 'pointer')
                .on('click', () => togglePort(item.port));
        });
        const progressTopY = y + 48 + HEADER_EXTRA + portsBlockH + 12;
        const prog = legend.append('g').attr('class','httpx-progress');
        prog.append('rect')
            .attr('x', x + 18)
            .attr('y', progressTopY)
            .attr('width', legendWidth - 36)
            .attr('height', 10)
            .attr('fill', '#343a40')
            .attr('stroke','#495057');
        prog.append('rect')
            .attr('x', x + 18)
            .attr('y', progressTopY)
            .attr('width', Math.floor(((window.__httpxProgress || 0) * (legendWidth - 36))))
            .attr('height', 10)
            .attr('fill', '#0d6efd');
        prog.append('text')
            .text(() => {
                const p = Math.round((window.__httpxProgress || 0) * 100);
                return p ? `${p}%` : '';
            })
            .attr('x', x + legendWidth - 24)
            .attr('y', progressTopY + 8)
            .attr('fill', '#adb5bd')
            .attr('font-size', '10px')
            .attr('text-anchor','end');
        // Убрали CIDR фильтр из легенды
    } catch (e) {
        console.error('Ошибка рендера легенды в SVG:', e);
    }
}

function startHttpxChecker() {
    try {
        const nodes = attackSurfaceData.nodes || [];
        const ips = nodes.filter(n => n.type === 'ip').map(n => n.id);
        const ports = Array.from(new Set((window.__portsLegendData?.ports || []).map(p => Number(p.port)).filter(Boolean)));
        const tasks = [];
        ips.forEach(ip => ports.forEach(port => tasks.push({ip, port})));
        let done = 0;
        const total = tasks.length || 1;
        const webPorts = new Set(window.__webPorts || []);
        window.__webPorts = Array.from(webPorts);
        const runNext = () => {
            if (!tasks.length) { window.__webPorts = Array.from(webPorts); window.__httpxProgress = 1; renderPortsLegendOverlay(window.currentSvg); return; }
            const t = tasks.shift();
            fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/httpx-check?ip=${encodeURIComponent(t.ip)}&port=${encodeURIComponent(t.port)}`)
                .then(r => r.json())
                .then(data => {
                    if (data && data.web) webPorts.add(Number(t.port));
                })
                .catch(() => {})
                .finally(() => {
                    done += 1;
                    window.__httpxProgress = done / total;
                    window.__webPorts = Array.from(webPorts);
                    renderPortsLegendOverlay(window.currentSvg);
                    setTimeout(runNext, 10);
                });
        };
        window.__httpxProgress = 0;
        renderPortsLegendOverlay(window.currentSvg);
        runNext();
    } catch (e) {}
}

function renderOrgLegendOverlay(svg) {
    try {
        if (!window.d3) { loadD3AndThen(function(){ renderOrgLegendOverlay(svg); }); return; }
        if (!svg || svg.empty()) return;
        svg.selectAll('g.org-legend').remove();
        const nodes = (window.__lastGraphNodes || attackSurfaceData.nodes || []).filter(n => n.type === 'cidr');
        let orgs = [];
        const asnMap = new Map();
        nodes.forEach(n => {
            if (n.organization) {
                orgs.push(String(n.organization));
                if (n.asn) asnMap.set(String(n.organization), String(n.asn));
            }
        });
        orgs = Array.from(new Set(orgs));
        const selectedOrg = window.__selectedOrganizationFilter || null;
        if (!orgs.length) return;
        const width = parseFloat(svg.attr('width')) || 800;
        const padding = 12;
        const legendWidth = 260;
        const x = width - legendWidth - padding - 360;
        const y = padding;
        const ROW_H = 18;
        const MAX_ROWS = 14;
        const items = orgs.slice(0, MAX_ROWS);
        const legendHeight = 36 + items.length * ROW_H;
        const defs = svg.select('defs').empty() ? svg.append('defs') : svg.select('defs');
        const shadow = defs.select('#orgLegendShadow').empty() ? defs.append('filter').attr('id','orgLegendShadow').attr('x','-50%').attr('y','-50%').attr('width','200%').attr('height','200%') : defs.select('#orgLegendShadow');
        if (shadow.select('feDropShadow').empty()) shadow.append('feDropShadow').attr('dx',0).attr('dy',2).attr('stdDeviation',2).attr('flood-color','#000').attr('flood-opacity',0.35);
        const legend = svg.append('g').attr('class', 'org-legend');
        legend.append('rect')
            .attr('x', x)
            .attr('y', y)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('width', legendWidth)
            .attr('height', legendHeight)
            .attr('fill', '#212529')
            .attr('stroke', '#444')
            .attr('stroke-width', 1)
            .attr('filter', 'url(#orgLegendShadow)')
            .attr('opacity', 0.85);
        legend.append('rect')
            .attr('x', x)
            .attr('y', y)
            .attr('width', 6)
            .attr('height', legendHeight)
            .attr('fill', '#ff4081');
        legend.append('text')
            .text('Организации')
            .attr('x', x + 18)
            .attr('y', y + 22)
            .attr('fill', '#f8f9fa')
            .attr('font-size', '13px')
            .attr('font-weight', 'bold');
        legend.append('text')
            .text('Сбросить')
            .attr('x', x + legendWidth - 18)
            .attr('y', y + 22)
            .attr('fill', '#adb5bd')
            .attr('font-size', '12px')
            .attr('text-anchor', 'end')
            .style('cursor', 'pointer')
            .on('click', () => { 
    try { 
        window.__selectedOrganizationFilter = null; 
        window.__lastGraphNodes = null;  // Очистка кэша для принудительной перезагрузки полных данных
        updateAttackSurfaceTable(); 
        loadAttackSurfaceGraph(currentAttackSurfaceId);  // Полная реинициализация графа как при выборе AS
    } catch (e) {} 
});
        legend.append('line')
            .attr('x1', x + 18)
            .attr('y1', y + 28)
            .attr('x2', x + legendWidth - 18)
            .attr('y2', y + 28)
            .attr('stroke', '#444');
        const startY = y + 44;
        items.forEach((org, idx) => {
            const itemY = startY + idx * ROW_H;
            const asn = asnMap.get(String(org)) || '';
            const isSel = selectedOrg && String(selectedOrg) === String(org);
            const row = legend.append('g');
            if (isSel) {
                row.append('rect')
                    .attr('x', x + 12)
                    .attr('y', itemY - 12)
                    .attr('width', legendWidth - 24)
                    .attr('height', ROW_H)
                    .attr('rx', 6)
                    .attr('ry', 6)
                    .attr('fill', '#343a40')
                    .attr('stroke', '#ff4081')
                    .attr('stroke-width', 1);
            }
            row.append('text')
                .text(asn ? `${org} (${asn})` : org)
                .attr('x', x + 18)
                .attr('y', itemY)
                .attr('fill', isSel ? '#f8f9fa' : '#e0e0e0')
                .attr('font-size', '12px')
                .attr('font-family', 'monospace')
                .style('cursor', 'pointer')
                .on('click', () => {
                    try {
                        const cur = window.__selectedOrganizationFilter || null;
                        window.__selectedOrganizationFilter = (cur === String(org)) ? null : String(org);
                        updateGraph();
                        updateAttackSurfaceTable();
                        if (window.currentSvg && window.currentZoom) {
                            try { setTimeout(function(){ try { zoomToFitCurrentGraph(0.9); } catch (e) {} }, 250); } catch (e) {}
                        }
                        if (window.currentSvg) renderOrgLegendOverlay(window.currentSvg);
                    } catch (e) {}
                });
        });
        if (orgs.length > MAX_ROWS) {
            legend.append('text')
                .text(`+${orgs.length - MAX_ROWS} ещё`)
                .attr('x', x + legendWidth - 18)
                .attr('y', y + legendHeight - 12)
                .attr('fill', '#adb5bd')
                .attr('font-size', '12px')
                .attr('text-anchor', 'end');
        }
    } catch (err) {
        console.error('Ошибка легенды организаций:', err);
    }
}
// ===== TCP парсинг и загрузка по CIDR =====
function parseTcpNmapXml(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) throw new Error('Ошибка парсинга XML файла');
            const entries = [];
            const hosts = xmlDoc.querySelectorAll('host');
            hosts.forEach(host => {
                const addrEl = host.querySelector('address[addrtype="ipv4"]');
                const address = addrEl ? addrEl.getAttribute('addr') : '';
                const portEls = host.querySelectorAll('port');
                portEls.forEach(portEl => {
                    const portId = portEl.getAttribute('portid');
                    const protocol = portEl.getAttribute('protocol') || 'tcp';
                    const state = portEl.querySelector('state')?.getAttribute('state');
                    const service = portEl.querySelector('service')?.getAttribute('name') || '';
                    if (protocol === 'tcp' && state === 'open' && portId) {
                        entries.push({ address, port: parseInt(portId, 10), protocol: 'tcp', service });
                    }
                });
            });
            window.parsedTcpEntries = entries;
            displayTcpPortsPreview(entries);
        } catch (error) {
            console.error('Ошибка парсинга XML:', error);
            alert('Ошибка при чтении XML файла: ' + error.message);
        }
    };
    reader.readAsText(file);
}

function displayTcpPortsPreview(entries) {
    const previewDiv = document.getElementById('tcpPortsPreviewContent');
    const previewContainer = document.getElementById('tcpPortsPreview');
    if (!entries || entries.length === 0) {
        previewDiv.innerHTML = '<div class="text-muted">TCP порты не найдены</div>';
    } else {
        const ipGroups = {};
        entries.forEach(e => {
            const ip = (e.address || '').trim();
            if (!ip) return;
            if (!ipGroups[ip]) ipGroups[ip] = [];
            ipGroups[ip].push(e);
        });
        let html = '';
        Object.entries(ipGroups).forEach(([ip, list]) => {
            html += `<div class="mb-2"><code>${ip}</code>: ` + list.map(item => `${item.port}/tcp${item.service ? ' (' + item.service + ')' : ''}`).join(', ') + '</div>';
        });
        previewDiv.innerHTML = html;
    }
    previewContainer.style.display = 'block';
    updateTcpUploadButton();
}

function updateTcpUploadButton() {
    const btn = document.getElementById('uploadTcpPortsBtn');
    const hasEntries = window.parsedTcpEntries && window.parsedTcpEntries.length > 0;
    if (btn) btn.disabled = !hasEntries;
}

function uploadTcpPorts() {
    if (!currentAttackSurfaceId) {
        alert('Сначала выберите Attack Surface');
        return;
    }
    if (!currentCidrNode || !currentCidrNode.id) {
        alert('CIDR не выбран');
        return;
    }
    if (!window.parsedTcpEntries || window.parsedTcpEntries.length === 0) {
        alert('Сначала выберите и обработайте XML файл');
        return;
    }
    const btn = document.getElementById('uploadTcpPortsBtn');
    btn.disabled = true;
    btn.textContent = 'Загружаю...';
    try {
        const byIp = {};
        window.parsedTcpEntries.forEach(e => {
            const ip = (e.address || '').trim();
            if (!ip) return;
            if (!byIp[ip]) byIp[ip] = [];
            byIp[ip].push({ port: e.port, protocol: 'tcp', service: e.service, status: 'open' });
        });
        const promises = [];
        let totalAdded = 0;
        let totalSkipped = 0;
        let updatedDomainsCount = 0;
        let matchedIps = 0;
        for (const [ip, ports] of Object.entries(byIp)) {
            if (isIpInCidr(ip, currentCidrNode.id)) {
                matchedIps += 1;
                promises.push(
                    fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/upload-nmap-ports`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ target_ip: ip, ports })
                    })
                    .then(r => r.json())
                    .then(data => {
                        if (data && data.success) {
                            totalAdded += data.total_added || 0;
                            totalSkipped += data.total_skipped || 0;
                            updatedDomainsCount += (data.updated_domains ? data.updated_domains.length : 0);
                        }
                    })
                );
            }
        }
        Promise.all(promises)
            .then(() => {
                alert(`Успешно загружено TCP портов: ${totalAdded}\nПропущено дубликатов: ${totalSkipped}\nОбновлено доменов: ${updatedDomainsCount}\nСопоставлено IP: ${matchedIps}`);
                bootstrap.Modal.getInstance(document.getElementById('uploadTcpPortsModal')).hide();
                if (typeof loadAttackSurfaceGraph === 'function') {
                    loadAttackSurfaceGraph(currentAttackSurfaceId);
                } else if (typeof updateAttackSurfaceDisplay === 'function') {
                    updateAttackSurfaceDisplay();
                }
            })
            .catch(err => {
                console.error('Ошибка:', err);
                alert('Произошла ошибка при загрузке TCP портов');
            })
            .finally(() => {
                btn.disabled = false;
                btn.textContent = 'Загрузить TCP порты';
            });
    } catch (err) {
        console.error('Ошибка подготовки TCP:', err);
        alert('Ошибка подготовки данных для загрузки TCP портов');
        btn.disabled = false;
        btn.textContent = 'Загрузить TCP порты';
    }
}
function showVisibleIps() {
    try {
        const ips = Array.from(new Set(window.__visibleIps || []));
        const container = document.getElementById('visibleIpsContainer');
        container.value = ips.join('\n');
        new bootstrap.Modal(document.getElementById('visibleIpsModal')).show();
    } catch (e) {
        alert('Ошибка отображения IP');
    }
}

function showVisiblePorts() {
    try {
        const ipPortsMap = window.__ipPortsMap || new Map();
        const selectedPortsSet = new Set(window.__portsLegendSelectedPorts || []);
        const selectedCidrs = new Set(window.__portsLegendSelectedCidrs || []);
        const ips = Array.from(new Set(window.__visibleIps || []));
        const ports = new Set();
        ips.forEach(ip => {
            const set = ipPortsMap.get(ip);
            if (!set || set.size === 0) return;
            set.forEach(s => {
                const m = s.match(/^([0-9]+)\/(tcp|udp)$/i);
                if (!m) return;
                const num = Number(m[1]);
                const proto = m[2].toLowerCase();
                if (selectedPortsSet.size > 0 && !selectedPortsSet.has(num)) return;
                ports.add(num);
            });
        });
        const arr = Array.from(ports).sort((a,b)=>a-b);
        const container = document.getElementById('visiblePortsContainer');
        container.value = arr.join(',');
        new bootstrap.Modal(document.getElementById('visiblePortsModal')).show();
    } catch (e) {
        alert('Ошибка отображения портов');
    }
}

function showVisibleDomains() {
    try {
        const domains = Array.from(new Set(window.__visibleDomains || []));
        const container = document.getElementById('visibleDomainsContainer');
        container.value = domains.join('\n');
        new bootstrap.Modal(document.getElementById('visibleDomainsModal')).show();
    } catch (e) {
        alert('Ошибка отображения доменов');
    }
}

function copyVisibleDomains() {
    try {
        const text = (document.getElementById('visibleDomainsContainer').value || '').trim();
        navigator.clipboard.writeText(text).then(() => {
            alert('Домены скопированы в буфер обмена');
        });
    } catch (e) {
        alert('Ошибка копирования');
    }
}

function downloadVisibleDomains() {
    try {
        const text = (document.getElementById('visibleDomainsContainer').value || '').trim();
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'domains.txt';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    } catch (e) {
        alert('Ошибка скачивания');
    }
}

function copyVisiblePorts() {
    try {
        const text = (document.getElementById('visiblePortsContainer').value || '').trim();
        navigator.clipboard.writeText(text).then(() => {
            alert('Порты скопированы в буфер обмена');
        });
    } catch (e) {
        alert('Ошибка копирования');
    }
}

function downloadVisiblePorts() {
    try {
        const text = (document.getElementById('visiblePortsContainer').value || '').trim();
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ports.txt';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    } catch (e) {
        alert('Ошибка скачивания');
    }
}

function copyVisibleIps() {
    try {
        const ips = Array.from(new Set(window.__visibleIps || []));
        const text = ips.join('\n');
        navigator.clipboard.writeText(text).then(() => {
            alert('IP скопированы в буфер обмена');
        });
    } catch (e) {
        alert('Ошибка копирования');
    }
}

function downloadVisibleIps() {
    try {
        const ips = Array.from(new Set(window.__visibleIps || []));
        const blob = new Blob([ips.join('\n')], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ips.txt';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    } catch (e) {
        alert('Ошибка скачивания');
    }
}
    window.showVisibleIps = showVisibleIps;
    window.copyVisibleIps = copyVisibleIps;

function parseHeadersInput(text) {
    try {
        const trimmed = (text || '').trim();
        if (!trimmed) return {};
        try {
            const obj = JSON.parse(trimmed);
            if (obj && typeof obj === 'object') return obj;
        } catch (e) {}
        const headers = {};
        trimmed.split('\n').forEach(line => {
            const l = line.trim();
            if (!l) return;
            const idx = l.indexOf(':');
            if (idx > 0) {
                const k = l.slice(0, idx).trim();
                const v = l.slice(idx + 1).trim();
                if (k) headers[k] = v;
            }
        });
        return headers;
    } catch (e) { return {}; }
}

function renderScreenshotPreviewForDomain(domain) {
    try {
        const dList = window.__attackSurfaceDomainsList || [];
        const match = dList.find(x => String(x.domain) === String(domain));
        const shot = match && match.screenshot ? match.screenshot : null;
        const ipId = null;
        const captureBtn = `<button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureDomain('${domain}')" title="Скриншот"><i class=\"fas fa-camera\"></i></button>`;
        if (!shot) return captureBtn;
        const url = `/static/${shot}`;
        return `
            <div class="d-inline-flex align-items-center gap-2">
                <img src="${url}" alt="preview" class="img-thumbnail" style="width:56px;height:36px;object-fit:cover;cursor:pointer" onclick="openScreenshot('${url}')">
                ${captureBtn}
            </div>
        `;
    } catch (e) { return `<button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureDomain('${domain}')" title="Скриншот"><i class=\"fas fa-camera\"></i></button>`; }
}

function renderScreenshotPreviewForIp(ip) {
    try {
        const ipMap = window.__ipIdMap || new Map();
        const ipId = ipMap.get(String(ip));
        const captureBtn = ipId ? `<button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureIp('${ip}', ${ipId})" title="Скриншот"><i class=\"fas fa-camera\"></i></button>` : '-';
        const ipList = window.__attackSurfaceIpsList || [];
        const match = ipList.find(x => String(x.ip) === String(ip));
        const shot = match && match.screenshot ? match.screenshot : null;
        if (!shot) return captureBtn;
        const url = `/static/${shot}`;
        return `
            <div class="d-inline-flex align-items-center gap-2">
                <img src="${url}" alt="preview" class="img-thumbnail" style="width:56px;height:36px;object-fit:cover;cursor:pointer" onclick="openScreenshot('${url}')">
                ${captureBtn}
            </div>
        `;
    } catch (e) { return '-'; }
}

function openScreenshot(url) {
    try {
        buildScreenshotItems();
        let idx = (window.__screenshotItems || []).findIndex(it => it.url === url);
        if (idx < 0) {
            if (!!window.__scopeOnly) {
                return;
            }
            window.__screenshotItems = [{ url, kind: '', key: '', code: null }].concat(window.__screenshotItems || []);
            idx = 0;
        }
        window.__screenshotIndex = idx;
        renderScreenshotModal();
        const modal = new bootstrap.Modal(document.getElementById('screenshotModal'));
        modal.show();
    } catch (e) {}
}

let __screenshotItems = [];
let __screenshotIndex = -1;

function buildScreenshotItems() {
    try {
        const items = [];
        const vDom = new Set(window.__visibleDomains || []);
        const vDomHosts = new Set(Array.from(vDom).map(x => normalizeHost(String(x || ''))));
        const vIp = new Set(window.__visibleIps || []);
        const scopeOnly = !!window.__scopeOnly;
        try {
            const dList = window.__attackSurfaceDomainsList || [];
            dList.forEach(d => {
                if (d && d.screenshot) {
                    const keepVis = vDomHosts.size ? vDomHosts.has(normalizeHost(String(d.domain || ''))) : false;
                    if (!keepVis) return;
                    const url = `/static/${d.screenshot}`;
                    items.push({ url, kind: 'domain', key: String(d.domain || ''), code: d.screenshot_status_code != null ? Number(d.screenshot_status_code) : null });
                }
            });
        } catch (e) {}
        try {
            const ipList = window.__attackSurfaceIpsList || [];
            ipList.forEach(i => {
                if (i && i.screenshot) {
                    const keepVis = vIp.size ? vIp.has(String(i.ip || '')) : false;
                    const keepScope = scopeOnly ? isIpInScope(String(i.ip || '')) : true;
                    const standaloneArr = window.__visibleIpStandalone || [];
                    const standaloneSet = new Set(standaloneArr.map(x => String(x)));
                    const keepStandalone = standaloneArr.length > 0 ? standaloneSet.has(String(i.ip || '')) : false;
                    if (!keepVis || !keepScope || !keepStandalone) return;
                    const url = `/static/${i.screenshot}`;
                    items.push({ url, kind: 'ip', key: String(i.ip || ''), code: i.screenshot_status_code != null ? Number(i.screenshot_status_code) : null });
                }
            });
        } catch (e) {}
        const seen = new Set();
        const dedup = [];
        items.forEach(it => { if (!seen.has(it.url)) { seen.add(it.url); dedup.push(it); } });
        window.__screenshotItems = dedup;
    } catch (e) { window.__screenshotItems = []; }
}

function renderScreenshotModal() {
    try {
        const items = window.__screenshotItems || [];
        const idx = window.__screenshotIndex;
        if (!items.length || idx == null || idx < 0 || idx >= items.length) return;
        const it = items[idx];
        const img = document.getElementById('screenshotModalImage');
        const cap = document.getElementById('screenshotModalCaption');
        img.onerror = function() {
            try {
                const arr = window.__screenshotItems || [];
                const i = window.__screenshotIndex || 0;
                if (i >= 0 && i < arr.length) {
                    arr.splice(i, 1);
                    window.__screenshotItems = arr;
                    if (!arr.length) {
                        img.src = '';
                        cap.textContent = 'Нет доступных скриншотов';
                        return;
                    }
                    window.__screenshotIndex = i % arr.length;
                    renderScreenshotModal();
                }
            } catch (e) {}
        };
        img.src = it.url;
        let label = '';
        if (it.kind === 'domain') label = `Домен: ${it.key}`;
        else if (it.kind === 'ip') label = `IP: ${it.key}`;
        if (it.code != null) label = label ? `${label} · HTTP ${it.code}` : `HTTP ${it.code}`;
        cap.textContent = label;
        window.__currentScreenshotMeta = it;
    } catch (e) {}
}

function prevScreenshot() {
    try {
        buildScreenshotItems();
        const items = window.__screenshotItems || [];
        if (!items.length) return;
        window.__screenshotIndex = (window.__screenshotIndex - 1 + items.length) % items.length;
        renderScreenshotModal();
    } catch (e) {}
}

function nextScreenshot() {
    try {
        buildScreenshotItems();
        const items = window.__screenshotItems || [];
        if (!items.length) return;
        window.__screenshotIndex = (window.__screenshotIndex + 1) % items.length;
        renderScreenshotModal();
    } catch (e) {}
}

function openScreenshotTarget() {
    try {
        const it = window.__currentScreenshotMeta;
        if (!it) return;
        let url = null;
        if (it.kind === 'domain') {
            try {
                url = String(it.key).startsWith('http') ? it.key : `https://${it.key}`;
            } catch (e) { url = String(it.key).startsWith('http') ? it.key : `https://${it.key}`; }
        } else if (it.kind === 'ip') {
            try {
                const ipList = window.__attackSurfaceIpsList || [];
                const m = ipList.find(x => String(x.ip) === String(it.key));
                url = (m && m.screenshot_url) ? m.screenshot_url : null;
            } catch (e) { url = null; }
        }
        if (url) window.open(url, '_blank', 'noopener,noreferrer');
    } catch (e) {}
}

function createCardFromScreenshot() {
    try {
        const it = window.__currentScreenshotMeta;
        if (!it || it.kind !== 'domain') { alert('Создание карточки поддерживается только для доменов'); return; }
        const domain = it.key;
        const url = String(domain).startsWith('http') ? domain : `https://${domain}`;
        showCreateSiteModal(domain, url);
    } catch (e) { alert('Ошибка открытия создания карточки'); }
}

let _hoverShotEl = null;
function hoverShotEnter(ev, url) {
    try {
        if (!_hoverShotEl) {
            _hoverShotEl = document.createElement('div');
            _hoverShotEl.style.position = 'fixed';
            _hoverShotEl.style.left = '0';
            _hoverShotEl.style.top = '0';
            _hoverShotEl.style.width = '360px';
            _hoverShotEl.style.height = '220px';
            _hoverShotEl.style.zIndex = '1060';
            _hoverShotEl.style.border = '1px solid #404040';
            _hoverShotEl.style.borderRadius = '6px';
            _hoverShotEl.style.boxShadow = '0 6px 16px rgba(0,0,0,0.4)';
            _hoverShotEl.style.backgroundColor = '#222';
            _hoverShotEl.style.overflow = 'hidden';
            _hoverShotEl.style.display = 'none';
            document.body.appendChild(_hoverShotEl);
        }
        _hoverShotEl.innerHTML = `<img src="${url}" style="width:100%;height:100%;object-fit:cover">`;
        _hoverShotEl.style.display = 'block';
        hoverShotMove(ev);
    } catch (e) {}
}
function hoverShotMove(ev) {
    try {
        if (!_hoverShotEl) return;
        const w = 360, h = 220, pad = 16;
        let x = ev.clientX + pad;
        let y = ev.clientY + pad;
        const vw = window.innerWidth || document.documentElement.clientWidth;
        const vh = window.innerHeight || document.documentElement.clientHeight;
        if (x + w + pad > vw) x = vw - w - pad;
        if (y + h + pad > vh) y = vh - h - pad;
        _hoverShotEl.style.left = x + 'px';
        _hoverShotEl.style.top = y + 'px';
    } catch (e) {}
}
function hoverShotLeave() {
    try {
        if (!_hoverShotEl) return;
        _hoverShotEl.style.display = 'none';
        _hoverShotEl.innerHTML = '';
    } catch (e) {}
}

function renderScreenshotImageOnlyForDomain(domain) {
    try {
        const dList = window.__attackSurfaceDomainsList || [];
        const match = dList.find(x => String(x.domain) === String(domain));
        const shot = match && match.screenshot ? match.screenshot : null;
        if (!shot) return '-';
        const url = `/static/${shot}`;
        const code = match && match.screenshot_status_code ? String(match.screenshot_status_code) : '';
        return `<img src="${url}" alt="preview" class="img-thumbnail" style="width:56px;height:36px;object-fit:cover;cursor:pointer" onclick="openScreenshot('${url}')" onmouseenter="hoverShotEnter(event, '${url}')" onmousemove="hoverShotMove(event)" onmouseleave="hoverShotLeave()" title="${code ? 'HTTP ' + code : ''}" onerror="this.style.display='none'">`;
    } catch (e) { return '-'; }
}

function renderScreenshotImageOnlyForIp(ip) {
    try {
        const ipList = window.__attackSurfaceIpsList || [];
        const match = ipList.find(x => String(x.ip) === String(ip));
        const shot = match && match.screenshot ? match.screenshot : null;
        if (!shot) return '-';
        const url = `/static/${shot}`;
        const code = match && match.screenshot_status_code ? String(match.screenshot_status_code) : '';
        return `<img src="${url}" alt="preview" class="img-thumbnail" style="width:56px;height:36px;object-fit:cover;cursor:pointer" onclick="openScreenshot('${url}')" onmouseenter="hoverShotEnter(event, '${url}')" onmousemove="hoverShotMove(event)" onmouseleave="hoverShotLeave()" title="${code ? 'HTTP ' + code : ''}" onerror="this.style.display='none'">`;
    } catch (e) { return '-'; }
}

function renderScreenshotStatusForDomain(domain) {
    try {
        const dList = window.__attackSurfaceDomainsList || [];
        const match = dList.find(x => String(x.domain) === String(domain));
        let code = match && match.screenshot_status_code != null ? Number(match.screenshot_status_code) : null;
        if (code == null && match) {
            try {
                const shot = String(match.screenshot || '').trim();
                const jsonUrl = shot ? `/static/${shot.replace(/\.png$/i, '.json')}` : null;
                if (jsonUrl) {
                    fetch(jsonUrl).then(r => r.ok ? r.json() : null).then(meta => {
                        if (!meta) return;
                        try {
                            const idx = dList.findIndex(x => String(x.domain) === String(domain));
                            if (idx >= 0) {
                                if (meta.status_code != null) dList[idx].screenshot_status_code = Number(meta.status_code);
                                window.__attackSurfaceDomainsList = dList;
                                updateAttackSurfaceTable();
                            }
                        } catch (e) {}
                    }).catch(()=>{});
                }
            } catch (e) {}
        }
        if (code == null && match) {
            try {
                const url = String(match.screenshot_url || '').trim();
                if (url) {
                    const u = new URL(url);
                    const host = u.hostname;
                    const ipList = window.__attackSurfaceIpsList || [];
                    const ipRec = ipList.find(i => String(i.ip) === String(host));
                    if (ipRec && ipRec.screenshot_status_code != null) {
                        code = Number(ipRec.screenshot_status_code);
                    }
                    if (code == null) {
                        try {
                            const shot = String(match.screenshot || '').trim();
                            const jsonUrl = shot ? `/static/${shot.replace(/\.png$/i, '.json')}` : null;
                            fetch(jsonUrl).then(r => r.ok ? r.json() : null).then(meta => {
                                if (!meta) return;
                                try {
                                    const dList = window.__attackSurfaceDomainsList || [];
                                    const idx = dList.findIndex(x => String(x.domain) === String(domain));
                                    if (idx >= 0) {
                                        if (meta.status_code != null) dList[idx].screenshot_status_code = Number(meta.status_code);
                                        window.__attackSurfaceDomainsList = dList;
                                        updateAttackSurfaceTable();
                                    }
                                } catch (e) {}
                            }).catch(()=>{});
                        } catch (e) {}
                    }
                }
            } catch (e) {}
        }
        if (code == null) return '<span class="badge" style="background-color:#6c757d;color:#fff">HTTP -</span>';
        let bg = '#28a745', fg = '#fff';
        if (code >= 300 && code < 400) { bg = '#17a2b8'; }
        else if (code >= 400 && code < 500) { bg = '#ffc107'; fg = '#212529'; }
        else if (code >= 500) { bg = '#dc3545'; }
        return `<span class="badge" style="background-color:${bg};color:${fg};font-weight:600">HTTP ${code}</span>`;
    } catch (e) { return '<span class="text-muted">-</span>'; }
}

function renderScreenshotStatusForIp(ip) {
    try {
        const ipList = window.__attackSurfaceIpsList || [];
        const match = ipList.find(x => String(x.ip) === String(ip));
        let code = match && match.screenshot_status_code != null ? Number(match.screenshot_status_code) : null;
        if (code == null && match) {
            try {
                const shot = String(match.screenshot || '').trim();
                const jsonUrl = shot ? `/static/${shot.replace(/\.png$/i, '.json')}` : null;
                if (jsonUrl) {
                    fetch(jsonUrl).then(r => r.ok ? r.json() : null).then(meta => {
                        if (!meta) return;
                        try {
                            const idx = ipList.findIndex(x => String(x.ip) === String(ip));
                            if (idx >= 0) {
                                if (meta.status_code != null) ipList[idx].screenshot_status_code = Number(meta.status_code);
                                window.__attackSurfaceIpsList = ipList;
                                updateAttackSurfaceTable();
                            }
                        } catch (e) {}
                    }).catch(()=>{});
                }
            } catch (e) {}
        }
        if (code == null && match) {
            try {
                const url = String(match.screenshot_url || '').trim();
                if (url) {
                    const u = new URL(url);
                    const host = u.hostname;
                    const dList = window.__attackSurfaceDomainsList || [];
                    const dRec = dList.find(d => String(d.ip || '') === String(ip) && String(d.screenshot_url || '').includes(host));
                    if (dRec && dRec.screenshot_status_code != null) {
                        code = Number(dRec.screenshot_status_code);
                    }
                    if (code == null) {
                        try {
                            const shot = String(match.screenshot || '').trim();
                            const jsonUrl = shot ? `/static/${shot.replace(/\.png$/i, '.json')}` : null;
                            fetch(jsonUrl).then(r => r.ok ? r.json() : null).then(meta => {
                                if (!meta) return;
                                try {
                                    const ipList = window.__attackSurfaceIpsList || [];
                                    const idx = ipList.findIndex(x => String(x.ip) === String(ip));
                                    if (idx >= 0) {
                                        if (meta.status_code != null) ipList[idx].screenshot_status_code = Number(meta.status_code);
                                        window.__attackSurfaceIpsList = ipList;
                                        updateAttackSurfaceTable();
                                    }
                                } catch (e) {}
                            }).catch(()=>{});
                        } catch (e) {}
                    }
                }
            } catch (e) {}
        }
        if (code == null) return '<span class="badge" style="background-color:#6c757d;color:#fff">HTTP -</span>';
        let bg = '#28a745', fg = '#fff';
        if (code >= 300 && code < 400) { bg = '#17a2b8'; }
        else if (code >= 400 && code < 500) { bg = '#ffc107'; fg = '#212529'; }
        else if (code >= 500) { bg = '#dc3545'; }
        return `<span class="badge" style="background-color:${bg};color:${fg};font-weight:600">HTTP ${code}</span>`;
    } catch (e) { return '<span class="text-muted">-</span>'; }
}

function renderScreenshotActionsForDomain(domain) {
    try {
        return `<button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureDomain('${domain}')" title="Скриншот"><i class=\"fas fa-camera\"></i></button>`;
    } catch (e) { return ''; }
}

function renderScreenshotActionsForIp(ip) {
    try {
        const ipMap = window.__ipIdMap || new Map();
        const ipId = ipMap.get(String(ip));
        const camera = ipId ? `<button class="btn btn-sm btn-outline-success" onclick="promptHeadersAndCaptureIp('${ip}', ${ipId})" title="Скриншот"><i class=\"fas fa-camera\"></i></button>` : '';
        const del = ipId ? `<button class="btn btn-sm btn-outline-danger ms-1" onclick="deleteAttackSurfaceIp('${ip}', ${ipId})" title="Удалить"><i class=\"fas fa-trash\"></i></button>` : '';
        return camera + del;
    } catch (e) { return ''; }
}

let _pendingScreenshotTarget = null;
function promptHeadersAndCaptureDomain(domain) {
    _pendingScreenshotTarget = { type: 'domain', domain };
    new bootstrap.Modal(document.getElementById('headersModal')).show();
}

function promptHeadersAndCaptureAll() {
    _pendingScreenshotTarget = { type: 'all' };
    new bootstrap.Modal(document.getElementById('headersModal')).show();
}

function promptHeadersAndCaptureIp(ip, ipId) {
    _pendingScreenshotTarget = { type: 'ip', ip, ipId };
    new bootstrap.Modal(document.getElementById('headersModal')).show();
}

function promptHeadersAndCaptureProject(projectId) {
    _pendingScreenshotTarget = { type: 'project', projectId };
    new bootstrap.Modal(document.getElementById('headersModal')).show();
}

async function promptHeadersAndCaptureProjectFromHeader() {
    try {
        let pid = null;
        if (window.currentAttackSurfaceId) {
            const r = await fetch(`/api/attack-surfaces/${window.currentAttackSurfaceId}`);
            const data = await r.json();
            if (data && data.success && data.attack_surface && data.attack_surface.project_id) {
                pid = Number(data.attack_surface.project_id);
            }
        }
        if (!pid) {
            const sel = document.getElementById('attackSurfaceProject');
            if (sel && sel.value) pid = Number(sel.value);
        }
        if (!pid) {
            _pendingScreenshotTarget = { type: 'all' };
            new bootstrap.Modal(document.getElementById('headersModal')).show();
            return;
        }
        _pendingScreenshotTarget = { type: 'project', projectId: pid };
        new bootstrap.Modal(document.getElementById('headersModal')).show();
    } catch (e) {
        alert('Ошибка определения проекта');
    }
}

async function submitHeadersModal() {
    try {
        const text = document.getElementById('headersText').value;
        const headers = parseHeadersInput(text);
        const onlyWeb = !!document.getElementById('onlyWebCheckbox')?.checked;
        const modalEl = document.getElementById('headersModal');
        const modalInst = bootstrap.Modal.getInstance(modalEl);
        if (modalInst) modalInst.hide();
        if (!_pendingScreenshotTarget) return;
        if (_pendingScreenshotTarget.type === 'domain') {
            const domain = _pendingScreenshotTarget.domain;
            const res = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains-with-sites`);
            const dData = await res.json();
            const resDomains = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
            const domData = await resDomains.json();
            if (!domData.success || !domData.domains) { alert('Домены не найдены'); return; }
            let key = String(domain || '').trim();
            let host = key;
            try {
                const low = key.toLowerCase();
                if (low.startsWith('http://') || low.startsWith('https://')) {
                    try { host = new URL(key).hostname; } catch (e) { host = key.replace(/^https?:\/\//i, '').split('/')[0]; }
                } else {
                    // если домен сохранен как «host», попробуем предпочесть https для запроса статуса
                    host = key.split('/')[0];
                    key = `https://${host}`;
                }
            } catch (e) {}
            const hostNorm = normalizeHost(host);
            let match = (domData.domains || []).find(x => normalizeHost(String(x.domain || '')) === hostNorm);
            if (!match) {
                if (/^\d+\.\d+\.\d+\.\d+$/.test(hostNorm)) {
                    try {
                        const ipsRes = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses`);
                        const ipsData = await ipsRes.json();
                        if (ipsData && ipsData.success) {
                            const ipRec = (ipsData.ips || []).find(i => String(i.ip) === hostNorm);
                            if (ipRec) {
                                const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses/${ipRec.id}/screenshot`, {
                                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ headers })
                                });
                                const data = await r.json();
                                if (data.success) {
                                    alert(`Готово: статус ${data.status_code || '-'}${data.screenshot ? '\nСкриншот сохранён' : ''}`);
                                    try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) {}
                                } else { alert('Ошибка: ' + (data.error || '')); }
                                return;
                            }
                        }
                    } catch (e) {}
                }
                alert('Домен не найден');
                return;
            }
            const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains/${match.id}/screenshot?delay_ms=8000`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ headers })
            });
            const data = await r.json();
            if (data.success) {
                alert(`Готово: статус ${data.status_code || '-'}${data.screenshot ? '\nСкриншот сохранён' : ''}`);
                try {
                    const dList = Array.isArray(window.__attackSurfaceDomainsList) ? window.__attackSurfaceDomainsList : [];
                    const idx = dList.findIndex(x => normalizeHost(String(x.domain||'')) === hostNorm);
                    if (idx >= 0) {
                        dList[idx] = { ...dList[idx], screenshot: data.screenshot || dList[idx].screenshot, screenshot_status_code: data.status_code };
                        window.__attackSurfaceDomainsList = dList;
                    }
                    updateAttackSurfaceTable();
                    loadAttackSurfaceGraph(currentAttackSurfaceId);
                } catch (e) {}
            } else { alert('Ошибка: ' + (data.error || '')); }
        } else if (_pendingScreenshotTarget.type === 'ip') {
            const ipId = _pendingScreenshotTarget.ipId;
            const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses/${ipId}/screenshot?delay_ms=8000`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ headers })
            });
            const data = await r.json();
            if (data.success) {
                alert(`Готово: статус ${data.status_code || '-'}${data.screenshot ? '\nСкриншот сохранён' : ''}`);
                try {
                    const ipList = Array.isArray(window.__attackSurfaceIpsList) ? window.__attackSurfaceIpsList : [];
                    const rec = ipList.find(x => Number(x.id) === Number(ipId));
                    if (rec) {
                        rec.screenshot = data.screenshot || rec.screenshot;
                        rec.screenshot_status_code = data.status_code;
                        window.__attackSurfaceIpsList = ipList;
                    }
                    updateAttackSurfaceTable();
                    loadAttackSurfaceGraph(currentAttackSurfaceId);
                } catch (e) {}
            } else { alert('Ошибка: ' + (data.error || '')); }
        } else if (_pendingScreenshotTarget.type === 'all') {
            try {
                const panel = document.getElementById('tableScreenshotsProgressPanel');
                const fill = document.getElementById('tableScreenshotsProgressFill');
                const text = document.getElementById('tableScreenshotsProgressText');
                const cur = document.getElementById('tableScreenshotsCurrent');
                panel.style.display = 'block';
                fill.style.width = '0%';
                text.textContent = '0%';
                cur.textContent = '';
            } catch (e) {}
            await runTableScreenshots(headers);
            
        } else if (_pendingScreenshotTarget.type === 'project') {
            const pid = _pendingScreenshotTarget.projectId;
            try { document.getElementById('projectScreenshotsSpinner').style.display = 'inline-flex'; } catch (e) {}
            const r = await fetch(`/api/projects/${pid}/screenshots`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ headers, only_web: onlyWeb })
            });
            const data = await r.json();
            if (data.success) {
                alert(`AS: ${data.attack_surfaces} | Домены: ${data.domains_done}/${data.domains_failed} | IP: ${data.ips_done}/${data.ips_failed}`);
                try {
                    if (currentAttackSurfaceId) loadAttackSurfaceGraph(currentAttackSurfaceId);
                } catch (e) {}
            } else { alert('Ошибка: ' + (data.error || '')); }
            try { document.getElementById('tableScreenshotsProgress').style.display = 'none'; } catch (e) {}
        }
    } catch (e) {
        alert('Ошибка запуска скриншота');
        try { document.getElementById('projectScreenshotsSpinner').style.display = 'none'; } catch (e) {}
    } finally {
        _pendingScreenshotTarget = null;
    }
}

async function computeTableTasks(onlyWeb) {
    const tasks = [];
    try {
        const resDomains = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
        const domData = await resDomains.json();
        const resIps = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses`);
        const ipData = await resIps.json();
        const webPorts = new Set(window.__webPorts || []);
        const ipPortsMap = window.__ipPortsMap || new Map();
        if (domData && domData.success && Array.isArray(domData.domains)) {
            domData.domains.forEach(d => {
                if (onlyWeb) {
                    const ip = String(d.ip || '').trim();
                    const set = ipPortsMap.get(ip);
                    const hasWeb = set && Array.from(set).some(s => { const m = s.match(/^([0-9]+)/); return m && webPorts.has(Number(m[1])); });
                    if (!hasWeb) return;
                }
                tasks.push({ type: 'domain', id: Number(d.id) });
            });
        }
        if (ipData && ipData.success && Array.isArray(ipData.ips)) {
            ipData.ips.forEach(ip => {
                if (onlyWeb) {
                    const set = ipPortsMap.get(String(ip.ip));
                    const hasWeb = set && Array.from(set).some(s => { const m = s.match(/^([0-9]+)/); return m && webPorts.has(Number(m[1])); });
                    if (!hasWeb) return;
                }
                tasks.push({ type: 'ip', id: Number(ip.id) });
            });
        }
    } catch (e) {}
    return tasks;
}

async function runTableScreenshots(headers) {
    try {
        const fill = document.getElementById('tableScreenshotsProgressFill');
        const text = document.getElementById('tableScreenshotsProgressText');
        const cur = document.getElementById('tableScreenshotsCurrent');
        const onlyWeb = !!document.getElementById('onlyWebCheckbox')?.checked;
        const tasks = await computeTableTasks(onlyWeb);
        if (!tasks || tasks.length === 0) {
            try { document.getElementById('tableScreenshotsProgressPanel').style.display = 'none'; } catch (e) {}
            alert('Нет задач для скриншотов. Проверьте порты или снимите фильтр «Только веб».');
            return;
        }
        const total = tasks.length || 1;
        let done = 0;
        const pool = 4;
        let idx = 0;
        async function worker() {
            while (idx < tasks.length) {
                const myIndex = idx++;
                const t = tasks[myIndex];
                try {
                    const url = t.type === 'domain'
                        ? `/api/attack-surfaces/${currentAttackSurfaceId}/domains/${t.id}/screenshot?delay_ms=8000`
                        : `/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses/${t.id}/screenshot?delay_ms=8000`;
                    cur.textContent = `${t.type === 'domain' ? 'домен' : 'IP'} #${t.id}`;
                const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ headers }) });
                await r.json();
            } catch (e) {}
            done += 1;
            const percent = Math.round((done / total) * 100);
            try { fill.style.width = percent + '%'; text.textContent = percent + '%'; } catch (e) {}
            }
        }
        const workers = Array.from({ length: Math.min(pool, tasks.length) }, () => worker());
        await Promise.all(workers);
        try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) {}
    } catch (e) {
    } finally {
        try { setTimeout(()=>{ document.getElementById('tableScreenshotsProgressPanel').style.display = 'none'; document.getElementById('tableScreenshotsProgressFill').style.width = '0%'; document.getElementById('tableScreenshotsProgressText').textContent='0%'; document.getElementById('tableScreenshotsCurrent').textContent=''; }, 500); } catch (e) {}
    }
}

async function deleteAllScreenshotsForAttackSurface() {
    try {
        if (!currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        if (!confirm('Удалить все скриншоты для текущего Attack Surface?')) return;
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/screenshots`, { method: 'DELETE' });
        const data = await r.json();
        if (data && data.success) {
            alert(`Удалено: домены ${data.domains_cleared}, IP ${data.ips_cleared}`);
            try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) {}
        } else {
            alert('Ошибка удаления: ' + (data && data.error ? data.error : '')); 
        }
    } catch (e) {
        alert('Ошибка удаления скриншотов');
    }
}

async function deleteAttackSurfaceIp(ip, ipId) {
    try {
        if (!currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        if (!confirm(`Удалить IP ${ip}?`)) return;
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses/${ipId}`, { method: 'DELETE' });
        const j = await r.json();
        if (j && j.success) {
            try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) { updateAttackSurfaceDisplay(); }
        } else {
            alert('Ошибка удаления: ' + (j && j.error ? j.error : '')); 
        }
    } catch (e) {
        alert('Ошибка удаления IP');
    }
}
function setAttackSurfaceSort(key) {
    const prev = window.__attackSurfaceSort || { key: 'cidr', dir: 'asc' };
    const dir = (prev.key === key) ? (prev.dir === 'asc' ? 'desc' : 'asc') : 'asc';
    window.__attackSurfaceSort = { key, dir };
    updateAttackSurfaceDisplay();
    try {
        const ids = { cidr: 'sortIndicatorCidr', ip: 'sortIndicatorIp', domain: 'sortIndicatorDomain', status: 'sortIndicatorStatus' };
        Object.values(ids).forEach(id => { const el = document.getElementById(id); if (el) el.className = 'fas fa-sort ms-1'; });
        const el = document.getElementById(ids[key]);
        if (el) el.className = 'fas ' + (dir === 'asc' ? 'fa-sort-up' : 'fa-sort-down') + ' ms-1';
    } catch (e) {}
}

function toggleCidrFilter() {
    const p = document.getElementById('cidrFilterPanel');
    if (!p) return;
    const visible = p.style.display && p.style.display !== 'none';
    p.style.display = visible ? 'none' : 'block';
    if (!visible) {
        try {
            const sel = document.getElementById('cidrFilterSelect');
            const opts = Array.from(sel.options).map(o => o.value);
            if (!opts.length) updateAttackSurfaceTable();
        } catch (e) {}
    }
}

function applyCidrFilter() {
    try {
        const sel = document.getElementById('cidrFilterSelect');
        const v = sel && sel.value ? sel.value : null;
        window.__selectedCidrFilter = v || null;
        updateAttackSurfaceTable();
        try { document.getElementById('attackSurfaceTableBody').scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (e) {}
    } catch (e) {}
}

function clearCidrFilter() {
    window.__selectedCidrFilter = null;
    updateAttackSurfaceTable();
}

document.addEventListener('DOMContentLoaded', function(){
    try {
        const btn = document.getElementById('toggleCidrFilterBtn');
        if (btn) btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); toggleCidrFilter(); });
    } catch (e) {}
    try {
        const collapse = document.getElementById('collapseCidrFilterBtn');
        if (collapse) collapse.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); toggleCidrFilter(); });
    } catch (e) {}
    try {
        const files = document.getElementById('vhostFiles');
        if (files) files.addEventListener('change', handleVhostFiles);
        const suffix = document.getElementById('vhostSuffix');
        if (suffix) suffix.addEventListener('input', recomputeVhostPreview);
        const clearBtn = document.getElementById('vhostClearBtn');
        if (clearBtn) clearBtn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); clearVhostUploads(e); });
        const search = document.getElementById('attackSurfaceSearch');
        if (search) search.addEventListener('input', function(){ try { applyAttackSurfaceSearch(); } catch (e) {} });
        try {
            const storedId = (function(){ try { return localStorage.getItem('__currentAttackSurfaceId'); } catch(e) { return null; } })();
            if (storedId) { window.currentAttackSurfaceId = Number(storedId) || null; }
            updateVhostCountBadge();
        } catch (e) {}
    } catch (e) {}
});

function showVhostModal() {
    try {
        const files = document.getElementById('vhostFiles');
        const suffix = document.getElementById('vhostSuffix');
        if (files) files.value = '';
        if (suffix) suffix.value = '';
        document.getElementById('vhostPreviewWrap').style.display = 'none';
        document.getElementById('vhostPreviewBody').innerHTML = '';
        try { if (window.currentAttackSurfaceId) { updateVhostCountBadge(); } } catch (e) {}
        new bootstrap.Modal(document.getElementById('vhostModal')).show();
    } catch (e) { alert('Не удалось открыть модальное окно VHost'); }
}

async function updateVhostCountBadge() {
    try {
        const badge = document.getElementById('vhostCountBadge');
        if (!badge || !window.currentAttackSurfaceId) return;
        const r = await fetch(`/api/attack-surfaces/${window.currentAttackSurfaceId}/vhost/findings`);
        let d = null;
        try { d = await r.json(); } catch (e) { d = null; }
        const arr = Array.isArray(d && d.findings) ? d.findings : [];
        const hosts = new Set(arr.map(x => normalizeHost(String(x.full_domain || ''))));
        badge.textContent = String(hosts.size);
    } catch (e) {}
}

function handleVhostFiles(ev) {
    try {
        const list = Array.from(ev.target.files || []);
        if (!list.length) return;
        window.__vhostRawEntries = [];
        let pending = list.length;
        list.forEach(file => {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const text = String(reader.result || '').replace(/\r\n/g,'\n');
                    const rows = parseCsv(text);
                    let statusIdx = -1;
                    let redirIdx = -1;
                    let hasHeader = false;
                    try {
                        const hdr = (rows[0] || []).map(c => String(c).trim().toLowerCase());
                        const cand = ['status_code','status','code','http_code'];
                        for (let i=0;i<cand.length;i++) { const idx = hdr.indexOf(cand[i]); if (idx !== -1) { statusIdx = idx; hasHeader = true; break; } }
                        redirIdx = hdr.indexOf('redirectlocation');
                    } catch (e) {}
                    const dataRows = hasHeader ? rows.slice(1) : rows;
                    const mapped = dataRows.map(r => {
                        const target = r[0] || '';
                        const entry = r[1] || r[0] || '';
                        let status = '';
                        if (hasHeader) {
                            status = String(r[statusIdx] || '').trim();
                        } else {
                            for (let i=2;i<r.length;i++) { const v = String(r[i] || '').trim(); if (/^[1-5][0-9]{2}$/.test(v)) { status = v; break; } }
                        }
                        const redirectlocation = hasHeader && redirIdx >= 0 ? String(r[redirIdx] || '').trim() : '';
                        return { filename: file.name, target, entry, status, redirectlocation };
                    });
                    window.__vhostRawEntries.push({ filename: file.name, entries: mapped });
                } catch (e) {}
                if (--pending === 0) recomputeVhostPreview();
            };
            reader.onerror = () => { if (--pending === 0) recomputeVhostPreview(); };
            reader.readAsText(file);
        });
    } catch (e) { alert('Ошибка чтения CSV'); }
}

function clearVhostUploads(ev) {
    try {
        try { if (ev) { ev.preventDefault(); ev.stopPropagation(); } } catch (e) {}
        if (!window.currentAttackSurfaceId) { alert('Сначала выберите Attack Surface'); return; }
        const url = `/api/attack-surfaces/${window.currentAttackSurfaceId}/vhost/clear`;
        fetch(url, { method: 'DELETE' })
            .then(async r => {
                if (r.ok) {
                    try { return await r.json(); } catch (_) { return { success: true }; }
                }
                throw new Error('DELETE not supported');
            })
            .then(d => {
                if (d && d.success) {
                    window.__vhostRawEntries = [];
                    window.__vhostPreviewEntries = [];
                    const files = document.getElementById('vhostFiles');
                    if (files) files.value = '';
                    const tbody = document.getElementById('vhostPreviewBody');
                    if (tbody) tbody.innerHTML = '';
                    const wrap = document.getElementById('vhostPreviewWrap');
                    if (wrap) wrap.style.display = 'none';
                    const filters = document.getElementById('vhostFilters');
                    if (filters) filters.style.display = 'none';
                    updateVhostCountBadge();
                    return;
                }
                throw new Error('DELETE failed');
            })
            .catch(() => {
                fetch(url, { method: 'POST' })
                    .then(async rr => {
                        if (rr.ok) {
                            try { return await rr.json(); } catch (_) { return { success: true }; }
                        }
                        throw new Error('POST failed');
                    })
                    .then(dd => {
                        if (dd && dd.success) {
                            window.__vhostRawEntries = [];
                            window.__vhostPreviewEntries = [];
                            const files = document.getElementById('vhostFiles');
                            if (files) files.value = '';
                            const tbody = document.getElementById('vhostPreviewBody');
                            if (tbody) tbody.innerHTML = '';
                            const wrap = document.getElementById('vhostPreviewWrap');
                            if (wrap) wrap.style.display = 'none';
                            const filters = document.getElementById('vhostFilters');
                            if (filters) filters.style.display = 'none';
                            updateVhostCountBadge();
                        } else {
                            alert('Не удалось очистить сохранённые VHost');
                        }
                    })
                    .catch(() => { alert('Ошибка запроса очистки VHost'); });
            });
    } catch (e) {}
}

function parseCsv(text) {
    const lines = text.split('\n').filter(l => l.trim().length);
    return lines.map(line => {
        const cells = [];
        let cur = '';
        let inq = false;
        for (let i=0;i<line.length;i++) {
            const ch = line[i];
            if (ch === '"') { inq = !inq; continue; }
            if (ch === ',' && !inq) { cells.push(cur); cur=''; continue; }
            cur += ch;
        }
        cells.push(cur);
        return cells.map(c => c.trim());
    });
}

function recomputeVhostPreview() {
    try {
        const suffix = String(document.getElementById('vhostSuffix').value || '').trim();
        const tbody = document.getElementById('vhostPreviewBody');
        const wrap = document.getElementById('vhostPreviewWrap');
        tbody.innerHTML = '';
        const byHost = new Map();
        const existing = new Set((window.__attackSurfaceDomainsList || []).map(d => normalizeHost(String(d.domain || ''))));
        window.__vhostRawEntries = window.__vhostRawEntries || [];
        window.__vhostRawEntries.forEach(file => {
            (file.entries||[]).forEach(e => {
                const target = e.target;
                const entry = e.entry;
                const tv = String(target || '').trim().toLowerCase();
                const ev = String(entry || '').trim().toLowerCase();
                if (tv === 'fuzz' || ev === 'fuzz') return;
                const full = suffix ? `${normalizeHost(target)}.${normalizeHost(suffix)}` : normalizeHost(target);
                const inAS = existing.has(normalizeHost(full));
                const key = normalizeHost(full);
                const item = { filename: file.filename, target, entry, redirectlocation: e.redirectlocation || '', full_domain: full, status: e.status || '-', exists_in_attack_surface: inAS };
                if (!byHost.has(key)) {
                    byHost.set(key, item);
                } else {
                    const prev = byHost.get(key);
                    const prefer = (prev.status === '-' && item.status !== '-') ? item : prev;
                    prefer.exists_in_attack_surface = prev.exists_in_attack_surface || item.exists_in_attack_surface;
                    byHost.set(key, prefer);
                }
            });
        });
        const entries = Array.from(byHost.values());
        if (!entries.length) { wrap.style.display = 'none'; const filters = document.getElementById('vhostFilters'); if (filters) filters.style.display = 'none'; return; }
        wrap.style.display = 'block';
        const filters = document.getElementById('vhostFilters');
        if (filters) filters.style.display = 'flex';
        entries.forEach(x => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td><input type=\"checkbox\" class=\"vhost-select\" data-domain=\"${x.full_domain}\" data-target=\"${x.target}\" data-entry=\"${x.entry}\" data-redirect=\"${x.redirectlocation || ''}\" data-status=\"${x.status}\"></td>
                <td>${x.target || '-'}</td>
                <td>${x.entry}</td>
                <td>${x.full_domain}</td>
                <td>${x.status}</td>
                <td>${x.exists_in_attack_surface ? '<span class=\"badge bg-success\">Есть</span>' : '<span class=\"badge bg-warning text-dark\">Новый домен</span>'}</td>
                <td class=\"text-muted\">—</td>
            `;
            tbody.appendChild(tr);
        });
        window.__vhostPreviewEntries = entries;
        resolveVhostPreviewDns();
    } catch (e) {}
}

async function resolveVhostPreviewDns() {
    try {
        const entries = window.__vhostPreviewEntries || [];
        const baseHosts = Array.from(new Set(entries.map(e => normalizeHost(e.full_domain))));
        const redirHosts = Array.from(new Set(entries.map(e => String(e.redirectlocation || '').trim()).filter(Boolean).map(h => normalizeHost(h))));
        const allHosts = Array.from(new Set([...baseHosts, ...redirHosts]));
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/vhost/resolve`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ domains: allHosts }) });
        const data = await r.json();
        if (data && data.success) {
            const tbody = document.getElementById('vhostPreviewBody');
            const map = data.results || {};
            Array.from(tbody.rows).forEach(row => {
                const full = normalizeHost(row.cells[3].textContent.trim());
                const cb = row.querySelector('.vhost-select');
                const redir = cb ? String(cb.getAttribute('data-redirect') || '').trim() : '';
                const rHost = redir ? normalizeHost(redir) : '';
                const iFull = map[full];
                if (iFull && iFull.resolve_ok) {
                    if (cb) { cb.dataset.resolved = '1'; cb.dataset.resolvedIp = iFull.ip || ''; }
                    row.cells[6].innerHTML = `<span class=\"badge bg-success\">${iFull.ip}</span>`;
                } else if (rHost && map[rHost] && map[rHost].resolve_ok) {
                    const ip = map[rHost].ip;
                    if (cb) { cb.dataset.resolved = '0'; cb.dataset.resolvedIp = ip || ''; }
                    row.cells[6].innerHTML = `<span class=\"badge bg-warning text-dark\">Redirect IP: ${ip}</span>`;
                } else {
                    if (cb) { cb.dataset.resolved = '0'; cb.dataset.resolvedIp = ''; }
                    row.cells[6].innerHTML = '<span class=\"badge bg-danger\">Не резолвится</span>';
                }
            });
        }
    } catch (e) {}
}

async function importVhostFindings() {
    try {
        const suffix = String(document.getElementById('vhostSuffix').value || '').trim();
        const filesPayload = (window.__vhostRawEntries||[]).map(f => ({
            filename: f.filename,
            target: (f.entries[0]||{}).target || '',
            entries: (f.entries||[])
                .filter(e => {
                    const tv = String(e.target || '').trim().toLowerCase();
                    const ev = String(e.entry || '').trim().toLowerCase();
                    return tv !== 'fuzz' && ev !== 'fuzz';
                })
                .map(e => ({ entry: e.entry, status: e.status, full_domain: suffix ? `${normalizeHost(e.target)}.${normalizeHost(suffix)}` : normalizeHost(e.target) }))
        }));
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/vhost/import`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ files: filesPayload, suffix }) });
        const data = await r.json();
        if (data && data.success) {
            alert(`Импортировано записей: ${data.saved.length}`);
            try { bootstrap.Modal.getInstance(document.getElementById('vhostModal')).hide(); } catch (e) {}
            try { updateVhostCountBadge(); } catch (e) {}
        } else {
            alert('Ошибка импорта: ' + (data.error || ''));
        }
    } catch (e) { alert('Ошибка импорта'); }
}

 

function toggleVhostSelectAll(cb){
    try {
        const boxes = document.querySelectorAll('#vhostPreviewTable .vhost-select');
        boxes.forEach(b => { b.checked = !!cb.checked; });
    } catch (e) {}
}

function applyVhostFilter(){
    try {
        const val = (document.getElementById('vhostFilterSelect').value || 'all');
        const rows = Array.from(document.querySelectorAll('#vhostPreviewTable tbody tr'));
        rows.forEach(row => {
            const status = row.cells[4].textContent.trim();
            const asBadge = row.cells[5].textContent.trim();
            const dnsText = row.cells[6].textContent.trim();
            let show = true;
            if (val === 'new') show = asBadge.includes('Новый домен');
            else if (val === 'resolved') show = !dnsText.includes('Не резолвится');
            else if (val === 'code2xx') show = /^2\d\d$/.test(status);
            else if (val === 'code3xx') show = /^3\d\d$/.test(status);
            else if (val === 'code4xx') show = /^4\d\d$/.test(status);
            else if (val === 'code5xx') show = /^5\d\d$/.test(status);
            row.style.display = show ? '' : 'none';
        });
    } catch (e) {}
}

async function addSelectedVhostToAttackSurface(){
    try {
        const selected = Array.from(document.querySelectorAll('#vhostPreviewTable .vhost-select:checked'));
        if (!selected.length) { alert('Выберите хотя бы одну запись'); return; }
        const domainsSet = new Set();
        const domainIpMap = {};
        selected.forEach(b => {
            const dom = (b.getAttribute('data-domain') || '').trim();
            const entry = (b.getAttribute('data-entry') || '').trim();
            const redir = (b.getAttribute('data-redirect') || '').trim();
            const resolved = b.getAttribute('data-resolved') === '1';
            const resolvedIp = (b.getAttribute('data-resolved-ip') || '').trim();
            let scheme = 'http';
            try {
                if (entry && /^https?:\/\//i.test(entry)) {
                    const u = new URL(entry);
                    scheme = (u.protocol || 'http:').replace(':','');
                }
            } catch (e) {}
            let ip = resolvedIp;
            try {
                if (!ip && /^https?:\/\//i.test(entry)) {
                    const u = new URL(entry);
                    const host = u.hostname;
                    if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) ip = host;
                }
            } catch (e) {}
            if (!ip && redir) {
                try {
                    const u = new URL(redir.startsWith('http') ? redir : `https://${redir}`);
                    const host = u.hostname;
                    if (/^\d+\.\d+\.\d+\.\d+$/.test(host)) ip = host;
                } catch (e) {}
            }
            if (!resolved && dom && ip) domainIpMap[dom] = ip;
            // Сохраняем домен с явной схемой, чтобы скриншот шёл по верной схеме
            if (dom) {
                const host = normalizeHost(dom);
                const withScheme = `${scheme}://${host}`;
                domainsSet.add(withScheme);
            }
            if (redir) {
                const rhost = normalizeHost(redir);
                const rWithScheme = `${scheme}://${rhost}`;
                domainsSet.add(rWithScheme);
            }
        });
        const domains = Array.from(domainsSet);
        const payload = { domains_and_ips: domains, resolve_domains: true, detect_cidr: true, domain_ip_map: domainIpMap, clear_existing: false };
        const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/analyze`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await r.json();
        if (j && j.success) {
            alert('Добавлено в Attack Surface');
            try { loadAttackSurfaceGraph(currentAttackSurfaceId); } catch (e) {}
            try {
                const resDomains = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
                const domData = await resDomains.json();
                if (domData && domData.success) window.__attackSurfaceDomainsList = domData.domains || [];
                const resIps = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/ip-addresses`);
                const ipData = await resIps.json();
                if (ipData && ipData.success) window.__attackSurfaceIpsList = ipData.ips || [];
                updateAttackSurfaceTable();
            } catch (e) {}
        } else {
            alert('Ошибка добавления: ' + (j && j.error ? j.error : '')); 
        }
    } catch (e) { alert('Ошибка добавления'); }
}

async function loadSavedVhostFindings(){
    try {
        const wrap = document.getElementById('vhostPreviewWrap');
        const tbody = document.getElementById('vhostPreviewBody');
        document.getElementById('vhostFilters').style.display = 'flex';
        wrap.style.display = 'block';
        const res = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/vhost/findings`);
        const data = await res.json();
        if (!data || !data.success) { alert('Не удалось загрузить сохранённые находки'); return; }
        try { updateVhostCountBadge(); } catch (e) {}
        let currentDomains = [];
        try {
            const r = await fetch(`/api/attack-surfaces/${currentAttackSurfaceId}/domains`);
            const j = await r.json();
            if (j && j.success) {
                currentDomains = j.domains || [];
                window.__attackSurfaceDomainsList = currentDomains;
            }
        } catch (e) {}
        const currentSet = new Set((currentDomains||[]).map(d => normalizeHost(String(d.domain||''))));
        const byHost = new Map();
        (data.findings||[]).forEach(x => {
            const item = {
                filename: x.source_filename,
                target: x.target,
                entry: x.entry,
                full_domain: x.full_domain,
                status: x.status || '-',
                exists_in_attack_surface: currentSet.has(normalizeHost(String(x.full_domain||''))),
                resolve_ok: !!x.resolve_ok,
                resolved_ip: x.resolved_ip || null,
                redirectlocation: x.redirectlocation || ''
            };
            const key = normalizeHost(String(item.full_domain||''));
            if (!byHost.has(key)) {
                byHost.set(key, item);
            } else {
                const prev = byHost.get(key);
                const prefer = (prev.status === '-' && item.status !== '-') ? item : prev;
                prefer.exists_in_attack_surface = prev.exists_in_attack_surface || item.exists_in_attack_surface;
                prefer.resolve_ok = prev.resolve_ok || item.resolve_ok;
                prefer.resolved_ip = prev.resolved_ip || item.resolved_ip;
                prefer.redirectlocation = prev.redirectlocation || item.redirectlocation;
                byHost.set(key, prefer);
            }
        });
        const items = Array.from(byHost.values());
        window.__vhostPreviewEntries = items;
        tbody.innerHTML = '';
        items.forEach(x=>{
            const tr = document.createElement('tr');
            const dnsCell = x.resolve_ok ? `<span class=\"badge bg-success\">${x.resolved_ip||''}</span>` : '<span class=\"badge bg-danger\">Не резолвится</span>';
            tr.innerHTML = `
                <td><input type=\"checkbox\" class=\"vhost-select\" data-domain=\"${x.full_domain}\" data-target=\"${x.target}\" data-entry=\"${x.entry}\" data-redirect=\"${x.redirectlocation || ''}\" data-status=\"${x.status}\" data-resolved=\"${x.resolve_ok ? '1' : '0'}\" data-resolved-ip=\"${x.resolved_ip || ''}\"></td>
                <td>${x.target || '-'}</td>
                <td>${x.entry || '-'}</td>
                <td>${x.full_domain}</td>
                <td>${x.status}</td>
                <td>${x.exists_in_attack_surface ? '<span class=\"badge bg-success\">Есть</span>' : '<span class=\"badge bg-warning text-dark\">Новый домен</span>'}</td>
                <td>${dnsCell}</td>
            `;
            tbody.appendChild(tr);
        });
        try { await resolveVhostPreviewDns(); } catch (e) {}
    } catch (e) { alert('Ошибка'); }
}

function applyAttackSurfaceSearch(){
    try {
        const q = (document.getElementById('attackSurfaceSearch').value || '').trim().toLowerCase();
        const tbody = document.getElementById('attackSurfaceTableBody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        if (!q) { rows.forEach(r => r.style.display = ''); return; }
        rows.forEach(r => { const text = (r.textContent || '').toLowerCase(); r.style.display = text.includes(q) ? '' : 'none'; });
    } catch (e) {}
}
</script>
{% endblock %}
